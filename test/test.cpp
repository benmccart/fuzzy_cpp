//  Copyright (c) 2025, Ben McCart
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.

#include "../include/fuzzy.hpp"
#include "./test.hpp"

#include <cmath>
#include <iostream>
#include <limits>

#define CATCH_CONFIG_MAIN
#include <catch.hpp>

//constexpr bool equivelant(float v0, float v1)
//{
//    return std::abs(v1 - v0) < 0.00001f;
//}


using namespace fuzzy;
using fuzzy::math::equivelant;

TEST_CASE("membership-bounds-check", "[boundscheck]")
{
    [[maybe_unused]] constexpr auto v0 = algabraic_product<>::apply(1.0f, 1.0f);
    [[maybe_unused]] constexpr auto v1 = algabraic_product<>::apply(0.0f, 0.0f);
    // FAIL constexpr auto v2 = algabraic_product<>::apply(-0.01f, 1.0f);
    // FAIL constexpr auto v0 = algabraic_product<>::apply(1.01f, 1.0f);
    
    validate_range(0.0);
    validate_range(0.5);
    validate_range(1.0);
    // FAIL validate_range(-0.00001);
    // FAIL validate_range( 1.00001);
}

TEST_CASE("t-norm-tests", "[tnormtests]") 
{
    REQUIRE(algabraic_product<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(algabraic_product<>::apply(0.00f, 0.50f) == 0.00f);
    REQUIRE(algabraic_product<>::apply(0.00f, 1.00f) == 0.00f);
    REQUIRE(algabraic_product<>::apply(0.50f, 1.00f) == 0.50f);
    REQUIRE(algabraic_product<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(algabraic_product<>::apply(0.50f, 0.50f) == 0.25f);

    REQUIRE(bounded_difference<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(bounded_difference<>::apply(0.00f, 0.50f) == 0.00f);
    REQUIRE(bounded_difference<>::apply(0.00f, 1.00f) == 0.00f);
    REQUIRE(bounded_difference<>::apply(0.50f, 1.00f) == 0.50f);
    REQUIRE(bounded_difference<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(bounded_difference<>::apply(0.50f, 0.50f) == 0.00f);
    REQUIRE(bounded_difference<>::apply(0.75f, 0.75f) == 0.50f);

    REQUIRE(drastic_product<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(drastic_product<>::apply(0.00f, 0.50f) == 0.00f);
    REQUIRE(drastic_product<>::apply(0.00f, 1.00f) == 0.00f);
    REQUIRE(drastic_product<>::apply(0.50f, 1.00f) == 0.50f);
    REQUIRE(drastic_product<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(drastic_product<>::apply(0.50f, 0.50f) == 0.00f);

    REQUIRE(einstein_product<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(einstein_product<>::apply(0.00f, 0.50f) == 0.00f);
    REQUIRE(einstein_product<>::apply(0.00f, 1.00f) == 0.00f);
    REQUIRE(einstein_product<>::apply(0.50f, 1.00f) == 0.50f);
    REQUIRE(einstein_product<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(einstein_product<>::apply(0.50f, 0.50f) == 0.20f);

    REQUIRE(hamacher_product<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(hamacher_product<>::apply(0.00f, 0.50f) == 0.00f);
    REQUIRE(hamacher_product<>::apply(0.00f, 1.00f) == 0.00f);
    REQUIRE(hamacher_product<>::apply(0.50f, 1.00f) == 0.50f);
    REQUIRE(hamacher_product<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(hamacher_product<>::apply(0.50f, 0.50f) == 0.33333333f);

    REQUIRE(minimum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(minimum<>::apply(0.00f, 0.50f) == 0.00f);
    REQUIRE(minimum<>::apply(0.00f, 1.00f) == 0.00f);
    REQUIRE(minimum<>::apply(0.50f, 1.00f) == 0.50f);
    REQUIRE(minimum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(minimum<>::apply(0.50f, 0.50f) == 0.50f);
}

TEST_CASE("t-conorm-tests", "[tconormtests]")
{
    REQUIRE(algabraic_sum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(algabraic_sum<>::apply(0.00f, 0.50f) == 0.50f);
    REQUIRE(algabraic_sum<>::apply(0.00f, 1.00f) == 1.00f);
    REQUIRE(algabraic_sum<>::apply(0.50f, 1.00f) == 1.00f);
    REQUIRE(algabraic_sum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(algabraic_sum<>::apply(0.50f, 0.50f) == 0.75f);

    REQUIRE(bounded_sum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(bounded_sum<>::apply(0.00f, 0.50f) == 0.50f);
    REQUIRE(bounded_sum<>::apply(0.00f, 1.00f) == 1.00f);
    REQUIRE(bounded_sum<>::apply(0.50f, 1.00f) == 1.00f);
    REQUIRE(bounded_sum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(bounded_sum<>::apply(0.50f, 0.50f) == 1.00f);
    REQUIRE(bounded_sum<>::apply(0.25f, 0.25f) == 0.50f);

    REQUIRE(drastic_sum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(drastic_sum<>::apply(0.00f, 0.50f) == 0.50f);
    REQUIRE(drastic_sum<>::apply(0.00f, 1.00f) == 1.00f);
    REQUIRE(drastic_sum<>::apply(0.50f, 1.00f) == 1.00f);
    REQUIRE(drastic_sum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(drastic_sum<>::apply(0.50f, 0.50f) == 1.00f);

    REQUIRE(einstein_sum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(einstein_sum<>::apply(0.00f, 0.50f) == 0.50f);
    REQUIRE(einstein_sum<>::apply(0.00f, 1.00f) == 1.00f);
    REQUIRE(einstein_sum<>::apply(0.50f, 1.00f) == 1.00f);
    REQUIRE(einstein_sum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(einstein_sum<>::apply(0.50f, 0.50f) == 0.80f);

    REQUIRE(hamacher_sum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(hamacher_sum<>::apply(0.00f, 0.50f) == 0.50f);
    REQUIRE(hamacher_sum<>::apply(0.00f, 1.00f) == 1.00f);
    REQUIRE(hamacher_sum<>::apply(0.50f, 1.00f) == 1.00f);
    REQUIRE(hamacher_sum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(hamacher_sum<>::apply(0.50f, 0.50f) == 0.66666666f);

    REQUIRE(maximum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(maximum<>::apply(0.00f, 0.50f) == 0.50f);
    REQUIRE(maximum<>::apply(0.00f, 1.00f) == 1.00f);
    REQUIRE(maximum<>::apply(0.50f, 1.00f) == 1.00f);
    REQUIRE(maximum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(maximum<>::apply(0.50f, 0.50f) == 0.50f);
}

TEST_CASE("basic_element-tests", "[basic_elementtests]")
{
    int_element e1{ 1, 1.0f };
    REQUIRE(e1.membership() == 1.0f);
    REQUIRE(e1.value() == 1);

    int_element e0{ 0, 0.0f };
    REQUIRE(e0.membership() == 0.0f);
    REQUIRE(e0.value() == 0);
    REQUIRE(e0 < e1);

    int_element eol{ 3, 0.4f };
    int_element eor{ 5, 0.4f };
    int_element ea = [](int_element const l, int_element const r) constexpr
    {
        return int_element{ l.value() + r.value(), l.membership() + r.membership() };
    }(eol, eor);
    REQUIRE(ea.value() == 8);
    REQUIRE(ea.membership() == 0.8f);

    REQUIRE(eol == int_element{ 3, 0.4f });
    REQUIRE(eol != int_element{ 3, 0.3999f });
    REQUIRE(eol != int_element{ -3, 0.4f });
    
    int_element ec{ e1 };
    REQUIRE(ec == e1);
    REQUIRE(ec != e0);
    ec = e0;
    REQUIRE(ec != e1);
    REQUIRE(ec == e0);

    int_element em{ std::move(ec) };
    REQUIRE(em == int_element{ 0, 0.0f });
    REQUIRE(em != int_element{ 1, 1.0f });

    em = int_element{ 2, 0.2f };
    REQUIRE(em == int_element{ 2, 0.2f });
    REQUIRE(em != int_element{ 2, 0.1f });

    // FAIL int_element em1{ -1, -1.0f };
    // FAIL int_element em1{ -1, -1.0001f };
    // FAIL int_element einf{ 1, std::numeric_limits<float>::infinity() };
    // FAIL int_element eninf{ -1, -std::numeric_limits<float>::infinity() };
}

TEST_CASE("empty-int_set", "[empty_set]")
{
    int_set empty;
    REQUIRE(empty.empty());
    REQUIRE(empty.size() == 0u);
    REQUIRE(all_ranges_valid(empty));
}

TEST_CASE("one-int_element-int_set", "[one_element_set]")
{
    int_set s1 = { {3, 1.0f} };
    REQUIRE(!s1.empty());
    REQUIRE(s1.size() == 1u);
    REQUIRE(all_ranges_valid(s1));
}

TEST_CASE("two-int_element-int_set", "[two_element_set]")
{
    int_set s2 = { {3, 1.0f}, {5, 1.0f} };
    REQUIRE(!s2.empty());
    REQUIRE(s2.size() == 2u);
    REQUIRE(all_ranges_valid(s2));
}

TEST_CASE("int_set-equivalence", "[set_equivalence]")
{
    int_set s1 = { {3, 1.0f}, {5, 1.0f} };
    int_set s2 = { {3, 1.0f}, {5, 1.0f} };
    REQUIRE(s1 == s2);
    REQUIRE(s1 == int_set{ { {3, 1.0f}, { 5, 1.0f } } });
    REQUIRE(s1 != int_set{ { {3, 1.0f} } });
    REQUIRE(s1 != int_set{ { { 5, 1.0f } } });
    REQUIRE(s1 != int_set{ { {3, 0.999f}, { 5, 1.0f } } });
    REQUIRE(s1 != int_set{ { {3, 1.0f}, { 5, 0.999f } } });
    REQUIRE(s1 != int_set{ { {4, 1.0f}, { 5, 1.0f } } });
    REQUIRE(s1 != int_set{ { {3, 1.0f}, { 4, 1.0f } } });
}

TEST_CASE("int_set-copy-construct", "[set_copy_construct]")
{
    int_set s1 = { {3, 1.0f}, {5, 1.0f} };
    int_set s2{ s1 };
    REQUIRE(!s2.empty());
    REQUIRE(s2.size() == 2u);
    REQUIRE(all_ranges_valid(s2));
    REQUIRE(s2 == s1);

    REQUIRE(s2 != int_set{ { {3, 0.0f}, { 4, 1.0f } } });
}

TEST_CASE("int_set-move-construct", "[set_move_construct]")
{
    int_set s1 = { {3, 1.0f}, {5, 1.0f} };
    int_set s2{ std::move(s1) };
    REQUIRE(!s2.empty());
    REQUIRE(s2.size() == 2u);
    REQUIRE(all_ranges_valid(s2));
    REQUIRE(s1.empty());
    REQUIRE(s2 == int_set{ { {3, 1.0f}, { 5, 1.0f } } });
}

TEST_CASE("int_set-assignment", "[set_assignment]")
{
    int_set s1 = { {3, 1.0f}, {5, 1.0f} };
    int_set s2;
    s2 = s1;
    REQUIRE(!s2.empty());
    REQUIRE(s2.size() == 2u);
    REQUIRE(all_ranges_valid(s2));
    REQUIRE(s2 == int_set{ { {3, 1.0f}, { 5, 1.0f } } });

    int_set s3;
    s3 = std::move(s1);
    REQUIRE(!s3.empty());
    REQUIRE(s3.size() == 2u);
    REQUIRE(all_ranges_valid(s3));
    REQUIRE(s3 == int_set{ { {3, 1.0f}, { 5, 1.0f } } });

    int_set s4;
    s4 = { {3, 1.0f}, { 5, 1.0f } };
    REQUIRE(!s4.empty());
    REQUIRE(s4.size() == 2u);
    REQUIRE(all_ranges_valid(s4));
    REQUIRE(s4 == int_set{ { {3, 1.0f}, { 5, 1.0f } } });
}

TEST_CASE("int_set-lowerbound", "[set_lowerbound]")
{
    int_set s = { {3, 1.0f}, {5, 0.8f} };

    // lb on keys
    REQUIRE(*s.lower_bound(0) == int_element{ 3, 1.0f });
    REQUIRE(*s.lower_bound(3) == int_element{ 3, 1.0f });
    REQUIRE(*s.lower_bound(4) == int_element{ 5, 0.8f });
    REQUIRE(*s.lower_bound(5) == int_element{ 5, 0.8f });
    REQUIRE(s.lower_bound(6) == s.end());

    // lb on elements
    REQUIRE(*s.lower_bound(int_element{ 1, 0.0f }) == int_element{ 3, 1.0f });
    REQUIRE(*s.lower_bound(int_element{ 3, 0.7f }) == int_element{ 3, 1.0f });
    REQUIRE(*s.lower_bound(int_element{ 4, 1.0f }) == int_element{ 5, 0.8f });
    REQUIRE(*s.lower_bound(int_element{ 5, 0.8f }) == int_element{ 5, 0.8f });
    REQUIRE(s.lower_bound(int_element{ 6, 0.0f }) == s.end());

    int_set const cs = { {3, 1.0f}, {5, 0.8f} };
    
    // lb on keys
    REQUIRE(*cs.lower_bound(0) == int_element{ 3, 1.0f });
    REQUIRE(*cs.lower_bound(3) == int_element{ 3, 1.0f });
    REQUIRE(*cs.lower_bound(4) == int_element{ 5, 0.8f });
    REQUIRE(*cs.lower_bound(5) == int_element{ 5, 0.8f });
    REQUIRE(cs.lower_bound(6) == cs.end());

    // lb on elements
    REQUIRE(*cs.lower_bound(int_element{ 1, 0.0f }) == int_element{ 3, 1.0f });
    REQUIRE(*cs.lower_bound(int_element{ 3, 0.7f }) == int_element{ 3, 1.0f });
    REQUIRE(*cs.lower_bound(int_element{ 4, 1.0f }) == int_element{ 5, 0.8f });
    REQUIRE(*cs.lower_bound(int_element{ 5, 0.8f }) == int_element{ 5, 0.8f });
    REQUIRE(cs.lower_bound(int_element{ 6, 0.0f }) == cs.end());

}

TEST_CASE("int_set-upperbound", "[set_upperbound]")
{
    int_set s = { {3, 1.0f}, {5, 0.8f} };

    // ub on keys
    REQUIRE(*s.upper_bound(0) == int_element{ 3, 1.0f });
    REQUIRE(*s.upper_bound(3) == int_element{ 5, 0.8f });
    REQUIRE(*s.upper_bound(4) == int_element{ 5, 0.8f });
    REQUIRE(s.upper_bound(5) == s.end());
    REQUIRE(s.upper_bound(6) == s.end());

    // ub on elements
    REQUIRE(*s.upper_bound(int_element{ 1, 0.0f }) == int_element{ 3, 1.0f });
    REQUIRE(*s.upper_bound(int_element{ 3, 0.7f }) == int_element{ 5, 0.8f });
    REQUIRE(*s.upper_bound(int_element{ 4, 1.0f }) == int_element{ 5, 0.8f });
    REQUIRE(s.upper_bound(int_element{ 5, 0.8f }) == s.end());
    REQUIRE(s.upper_bound(int_element{ 6, 0.0f }) == s.end());

    int_set const cs = { {3, 1.0f}, {5, 0.8f} };

    // ub on keys
    REQUIRE(*cs.upper_bound(0) == int_element{ 3, 1.0f });
    REQUIRE(*cs.upper_bound(3) == int_element{ 5, 0.8f });
    REQUIRE(*cs.upper_bound(4) == int_element{ 5, 0.8f });
    REQUIRE(cs.upper_bound(5) == cs.end());
    REQUIRE(cs.upper_bound(6) == cs.end());

    // ub on elements
    REQUIRE(*cs.upper_bound(int_element{ 1, 0.0f }) == int_element{ 3, 1.0f });
    REQUIRE(*cs.upper_bound(int_element{ 3, 0.7f }) == int_element{ 5, 0.8f });
    REQUIRE(*cs.upper_bound(int_element{ 4, 1.0f }) == int_element{ 5, 0.8f });
    REQUIRE(cs.upper_bound(int_element{ 5, 0.8f }) == cs.end());
    REQUIRE(cs.upper_bound(int_element{ 6, 0.0f }) == cs.end());
}

TEST_CASE("int_set-find", "[set_find]")
{
    // find on keys
    int_set s = { {3, 1.0f}, {5, 0.8f} };
    REQUIRE(s.find(0) == s.end());
    REQUIRE(*s.find(3) == int_element{ 3, 1.0f });
    REQUIRE(s.find(4) == s.end());
    REQUIRE(*s.find(5) == int_element{ 5, 0.8f });
    REQUIRE(s.find(6) == s.end());

    int_set const cs = { {3, 1.0f}, {5, 0.8f} };
    REQUIRE(cs.find(0) == cs.end());
    REQUIRE(*cs.find(3) == int_element{ 3, 1.0f });
    REQUIRE(cs.find(4) == cs.end());
    REQUIRE(*cs.find(5) == int_element{ 5, 0.8f });
    REQUIRE(cs.find(6) == cs.end());

    // find on elements
    REQUIRE(s.find(int_element{ 0, 0.0f }) == s.end());
    REQUIRE(*s.find(int_element{ 3, 1.0f }) == int_element{ 3, 1.0f });
    REQUIRE(s.find(int_element{ 3, 0.0f }) == s.end());
    REQUIRE(s.find(int_element{ 4, 0.0f }) == s.end());
    REQUIRE(*s.find(int_element{ 5, 0.8f }) == int_element{ 5, 0.8f });
    REQUIRE(s.find(int_element{ 6, 1.0f }) == s.end());

    REQUIRE(cs.find(int_element{ 0, 1.0f }) == cs.end());
    REQUIRE(*cs.find(int_element{ 3, 1.0f }) == int_element{ 3, 1.0f });
    REQUIRE(cs.find(int_element{ 4, 1.0f }) == cs.end());
    REQUIRE(*cs.find(int_element{ 5, 0.8f }) == int_element{ 5, 0.8f });
    REQUIRE(cs.find(int_element{ 5, 0.7f }) == cs.end());
    REQUIRE(cs.find(int_element{ 6, 0.0f }) == cs.end());
}

TEST_CASE("int_set-contains", "[set_contains]")
{
    // find on keys
    int_set const cs = { {3, 1.0f}, {5, 0.8f} };
    REQUIRE(!cs.contains(0));
    REQUIRE(cs.contains(3));
    REQUIRE(!cs.contains(4));
    REQUIRE(cs.contains(5));
    REQUIRE(!cs.contains(6));

    // find on elements
    REQUIRE(!cs.contains(int_element{ 0, 1.0f }));
    REQUIRE(cs.contains(int_element{ 3, 1.0f }));
    REQUIRE(!cs.contains(int_element{ 3, 0.7f }));
    REQUIRE(!cs.contains(int_element{ 4, 1.0f }));
    REQUIRE(cs.contains(int_element{ 5, 0.8f }));
    REQUIRE(!cs.contains(int_element{ 5, 1.0f }));
    REQUIRE(!cs.contains(int_element{ 6, 0.0f }));
}

TEST_CASE("int_set-count", "[set_count]")
{
    // count on keys
    int_set const cs = { {3, 1.0f}, {5, 0.8f} };
    REQUIRE(cs.count(0) == 0u);
    REQUIRE(cs.count(3) == 1u);
    REQUIRE(cs.count(4) == 0u);
    REQUIRE(cs.count(5) == 1u);
    REQUIRE(cs.count(6) == 0u);

    // count on elements
    REQUIRE(cs.count(int_element{ 0, 1.0f }) == 0u);
    REQUIRE(cs.count(int_element{ 3, 1.0f }) == 1u);
    REQUIRE(cs.count(int_element{ 3, 0.7f }) == 0u);
    REQUIRE(cs.count(int_element{ 4, 1.0f }) == 0u);
    REQUIRE(cs.count(int_element{ 5, 0.8f }) == 1u);
    REQUIRE(cs.count(int_element{ 5, 1.0f }) == 0u);
    REQUIRE(cs.count(int_element{ 6, 0.0f }) == 0u);
}


TEST_CASE("int_set-insert", "[set_insert]")
{
    // insertion of elements.
    int_set cs;
    cs.insert({ {3, 1.0f}, {5, 0.8f} });
    REQUIRE(cs.count(0) == 0u);
    REQUIRE(cs.count(3) == 1u);
    REQUIRE(cs.count(4) == 0u);
    REQUIRE(cs.count(5) == 1u);
    REQUIRE(cs.count(6) == 0u);

    cs.insert(int_element{ 4, 0.4f });
    REQUIRE(cs.contains(4));
    cs.insert(cs.cend(), int_element{ 0, 0.3f });
    REQUIRE(cs.contains(0));

    std::vector<int_element> const other = { {7, 1.0f}, {5, 0.0f}, {6, 0.6f} };
    cs.insert(other.begin(), other.end());
    REQUIRE(cs.contains(int_element{ 5, 0.8f }));
    REQUIRE(cs.contains(int_element{ 6, 0.6f }));
    REQUIRE(cs.contains(int_element{ 7, 1.0f }));

    auto pair1 = cs.insert(cs.begin(), int_element{ 4, 1.0f });
    REQUIRE(pair1.second == false);
    REQUIRE(pair1.first != cs.end());

    auto pair2 = cs.insert(cs.end(), int_element{ -1, 0.1f });
    REQUIRE(pair2.second == true);
    REQUIRE(pair2.first == cs.begin());
}


TEST_CASE("TR0-int_set", "[TR0_set]")
{
    int_set item = make_triangle<float>(4, 8, 12);
    REQUIRE(item.membership(2) == 0.0f);
    REQUIRE(item.membership(4) == 0.0f);
    REQUIRE(item.membership(6) == 0.5f);
    REQUIRE(item.membership(8) == 1.0f);
    REQUIRE(item.membership(10) == 0.5f);
    REQUIRE(item.membership(12) == 0.0f);
    REQUIRE(item.membership(14) == 0.0f);

    REQUIRE(!item.empty());
    REQUIRE(item.size() == 3u);
    REQUIRE(all_ranges_valid(item));
    REQUIRE(item.find(int_element{ 0, 0.3f }) == item.cend());
    REQUIRE(item.find(int_element{ 8, 1.0f }) != item.cend());
    REQUIRE(!item.contains(0));
    REQUIRE(item.contains(4));
    REQUIRE(item.count(0) == 0);
    REQUIRE(item.count(4) == 1);
    REQUIRE(item.count(int_element{ 0, 0.3f }) == 0);
    REQUIRE(item.count(int_element{ 12, 0.0f }) == 1);
}

TEST_CASE("TR1-int_set", "[TR1_set]")
{
    int_set item = make_trapezoid<float>(4, 8, 12, 16);
    REQUIRE(item.membership(2) == 0.0f);
    REQUIRE(item.membership(4) == 0.0f);
    REQUIRE(item.membership(6) == 0.5f);
    REQUIRE(item.membership(8) == 1.0f);
    REQUIRE(item.membership(10) == 1.0f);
    REQUIRE(item.membership(12) == 1.0f);
    REQUIRE(item.membership(14) == 0.5f);
    REQUIRE(item.membership(16) == 0.0f);
    REQUIRE(item.membership(18) == 0.0f);

    REQUIRE(!item.empty());
    REQUIRE(item.size() == 4u);
    REQUIRE(all_ranges_valid(item));
    REQUIRE(item.find(int_element{ 0, 0.3f }) == item.cend());
    REQUIRE(item.find(int_element{ 8, 1.0f }) != item.cend());
    REQUIRE(*item.find(int_element{ 8, 1.0f }) == int_element{ 8, 1.0f });
    REQUIRE(!item.contains(0));
    REQUIRE(item.contains(4));
    REQUIRE(item.count(0) == 0);
    REQUIRE(item.count(4) == 1);
    REQUIRE(item.count(int_element{ 8, 1.0f }) == 1);
    REQUIRE(item.count(int_element{ std::numeric_limits<int>::max(), 0.3f }) == 0);
    REQUIRE(item.count(int_element{ std::numeric_limits<int>::max(), 0.0f }) == 0);
}

TEST_CASE("SET-complement", "[SET_complement]")
{
    // Default case.
    int_set const empty;
    int_set const empty_c = ~empty;
    REQUIRE(empty_c.size() == 2u);
    REQUIRE(empty_c.membership(std::numeric_limits<int>::lowest()) == 1.0f);
    REQUIRE(empty_c.membership(0) == 1.0f);
    REQUIRE(empty_c.membership(std::numeric_limits<int>::max()) == 1.0f);
    
    // Common case.
    int_set const tri = make_triangle<float>(4,8,12);
    int_set const tri_c = ~tri;
    REQUIRE(tri_c.membership(std::numeric_limits<int>::lowest()) == 1.0f);
    REQUIRE(tri_c.membership(4) == 1.0f);
    REQUIRE(tri_c.membership(6) == 0.5f);
    REQUIRE(tri_c.membership(8) == 0.0f);
    REQUIRE(tri_c.membership(10) == 0.5f);
    REQUIRE(tri_c.membership(12) == 1.0f);
    REQUIRE(tri_c.membership(std::numeric_limits<int>::max()) == 1.0f);

    // Extreme boundary case
    int_set const eb_tri = make_triangle<float>(std::numeric_limits<int>::lowest(), 0, std::numeric_limits<int>::max());
    int_set const eb_tri_c = ~eb_tri;
    REQUIRE(eb_tri_c.membership(std::numeric_limits<int>::lowest()) == 1.0f);
    REQUIRE(eb_tri_c.membership(0) == 0.0f);
    REQUIRE(eb_tri_c.membership(std::numeric_limits<int>::max()) == 1.0f);

    // Near extreme boundary case
    int_set const neb_tri = make_triangle<float>(std::numeric_limits<int>::lowest() + 1, 0, std::numeric_limits<int>::max() - 1);
    int_set const neb_tri_c = ~neb_tri;
    REQUIRE(neb_tri_c.membership(std::numeric_limits<int>::lowest()) == 1.0f);
    REQUIRE(neb_tri_c.membership(std::numeric_limits<int>::lowest() + 1) == 1.0f);
    REQUIRE(neb_tri_c.membership(0) == 0.0f);
    REQUIRE(neb_tri_c.membership(std::numeric_limits<int>::max() - 1) == 1.0f);
    REQUIRE(neb_tri_c.membership(std::numeric_limits<int>::max()) == 1.0f);
}

TEST_CASE("SET-intersection", "[SET_intersection]")
{
    // Common case left-right
    int_set si_cc_lr = set_intersection<fuzzy::minimum>(make_triangle<float>(3, 7, 11), make_triangle<float>(4, 8, 12));
    REQUIRE(si_cc_lr.membership(3) == 0.0f);
    REQUIRE(si_cc_lr.membership(4) == 0.0f);
    REQUIRE(si_cc_lr.membership(5) == 0.25f);
    REQUIRE(si_cc_lr.membership(6) == 0.50f);
    REQUIRE(si_cc_lr.membership(7) == 0.75f);
    REQUIRE(si_cc_lr.membership(8) == 0.75f);
    REQUIRE(si_cc_lr.membership(9) == 0.50f);
    REQUIRE(si_cc_lr.membership(10) == 0.25f);
    REQUIRE(si_cc_lr.membership(11) == 0.0f);
    REQUIRE(si_cc_lr.membership(12) == 0.0f);

    // Common case right-left
    int_set si_cc_rl = set_intersection<fuzzy::minimum>(make_triangle<float>(4, 8, 12), make_triangle<float>(3, 7, 11));
    REQUIRE(si_cc_rl.membership(3) == 0.0f);
    REQUIRE(si_cc_rl.membership(4) == 0.0f);
    REQUIRE(si_cc_rl.membership(5) == 0.25f);
    REQUIRE(si_cc_rl.membership(6) == 0.50f);
    REQUIRE(si_cc_rl.membership(7) == 0.75f);
    REQUIRE(si_cc_rl.membership(8) == 0.75f);
    REQUIRE(si_cc_rl.membership(9) == 0.50f);
    REQUIRE(si_cc_rl.membership(10) == 0.25f);
    REQUIRE(si_cc_rl.membership(11) == 0.0f);
    REQUIRE(si_cc_rl.membership(12) == 0.0f);

    // Boundary case left-right
    int_set si_bc_lr = set_intersection<fuzzy::minimum>(make_triangle<float>(4, 8, 12), make_triangle<float>(12, 16, 20));
    REQUIRE(si_bc_lr.membership(3) == 0.0f);
    REQUIRE(si_bc_lr.membership(4) == 0.0f);
    REQUIRE(si_bc_lr.membership(5) == 0.0f);
    REQUIRE(si_bc_lr.membership(11) == 0.0f);
    REQUIRE(si_bc_lr.membership(12) == 0.0f);
    REQUIRE(si_bc_lr.membership(13) == 0.0f);
    REQUIRE(si_bc_lr.membership(19) == 0.0f);
    REQUIRE(si_bc_lr.membership(20) == 0.0f);
    REQUIRE(si_bc_lr.membership(21) == 0.0f);

    int_set si_bc_rl = set_intersection<fuzzy::minimum>(make_triangle<float>(12, 16, 20), make_triangle<float>(4, 8, 12));
    REQUIRE(si_bc_rl.membership(3) == 0.0f);
    REQUIRE(si_bc_rl.membership(4) == 0.0f);
    REQUIRE(si_bc_rl.membership(5) == 0.0f);
    REQUIRE(si_bc_rl.membership(11) == 0.0f);
    REQUIRE(si_bc_rl.membership(12) == 0.0f);
    REQUIRE(si_bc_rl.membership(13) == 0.0f);
    REQUIRE(si_bc_rl.membership(19) == 0.0f);
    REQUIRE(si_bc_rl.membership(20) == 0.0f);
    REQUIRE(si_bc_rl.membership(21) == 0.0f);

    // Boundary past each-other case
    int_set si_bp_lr = set_intersection<fuzzy::minimum>(make_triangle<float>(-12, -8, -4), make_triangle<float>(12, 16, 20));
    REQUIRE(si_bp_lr.membership(-13) == 0.0f);
    REQUIRE(si_bp_lr.membership(-12) == 0.0f);
    REQUIRE(si_bp_lr.membership(-7) == 0.0f);
    REQUIRE(si_bp_lr.membership(-3) == 0.0f);
    REQUIRE(si_bp_lr.membership(11) == 0.0f);
    REQUIRE(si_bp_lr.membership(12) == 0.0f);
    REQUIRE(si_bp_lr.membership(17) == 0.0f);
    REQUIRE(si_bp_lr.membership(20) == 0.0f);
    REQUIRE(si_bp_lr.membership(21) == 0.0f);

    int_set si_bp_rl = set_intersection<fuzzy::minimum>(make_triangle<float>(12, 16, 20), make_triangle<float>(-12, -8, -4));
    REQUIRE(si_bp_rl.membership(-13) == 0.0f);
    REQUIRE(si_bp_rl.membership(-12) == 0.0f);
    REQUIRE(si_bp_rl.membership(-7) == 0.0f);
    REQUIRE(si_bp_rl.membership(-3) == 0.0f);
    REQUIRE(si_bp_rl.membership(11) == 0.0f);
    REQUIRE(si_bp_rl.membership(12) == 0.0f);
    REQUIRE(si_bp_rl.membership(17) == 0.0f);
    REQUIRE(si_bp_rl.membership(20) == 0.0f);
    REQUIRE(si_bp_rl.membership(21) == 0.0f);
}

TEST_CASE("SET-operation-sequence", "[SET_operation_sequence]")
{
    int_set a_even = make_triangle<float>(16, 24, 32);
    int_set b_even = make_triangle<float>(24, 32, 40);
    int_set c1_even = set_intersection<fuzzy::minimum>(a_even, b_even);
    REQUIRE(c1_even.size() == 3);
    REQUIRE(c1_even.membership(24) == 0.0f);
    REQUIRE(c1_even.membership(28) == 0.5f);
    REQUIRE(c1_even.membership(32) == 0.0f);

    int_set c2_even = set_intersection<fuzzy::minimum>(b_even, a_even);
    REQUIRE(c2_even.size() == 3);
    REQUIRE(c2_even.membership(24) == 0.0f);
    REQUIRE(c2_even.membership(28) == 0.5f);
    REQUIRE(c2_even.membership(32) == 0.0f);

    int_set a_minor = make_triangle<float>(16, 24, 32);
    int_set b_minor = make_triangle<float>(28, 36, 44);
    int_set c1_minor = set_intersection<fuzzy::minimum>(a_minor, b_minor);
    REQUIRE(c1_minor.size() == 3);
    REQUIRE(c1_minor.membership(28) == 0.0f);
    REQUIRE(c1_minor.membership(30) == 0.25f);
    REQUIRE(c1_minor.membership(32) == 0.0f);

    int_set c2_minor = set_intersection<fuzzy::minimum>(b_minor, a_minor);
    REQUIRE(c2_minor.size() == 3);
    REQUIRE(c2_minor.membership(28) == 0.0f);
    REQUIRE(c2_minor.membership(30) == 0.25f);
    REQUIRE(c2_minor.membership(32) == 0.0f);
}

TEST_CASE("SET-union", "[SET_union]")
{
    // Common case 
    int_set su_cc_lr = set_union<fuzzy::maximum>(make_triangle<float>(3, 7, 11), make_triangle<float>(4, 8, 12));
    REQUIRE(su_cc_lr.membership(3) == 0.0f);
    REQUIRE(su_cc_lr.membership(4) == 0.25f);
    REQUIRE(su_cc_lr.membership(5) == 0.50f);
    REQUIRE(su_cc_lr.membership(6) == 0.75f);
    REQUIRE(su_cc_lr.membership(7) == 1.0f);
    REQUIRE(su_cc_lr.membership(8) == 1.0f);
    REQUIRE(su_cc_lr.membership(9) == 0.75f);
    REQUIRE(su_cc_lr.membership(10) == 0.50f);
    REQUIRE(su_cc_lr.membership(11) == 0.25f);
    REQUIRE(su_cc_lr.membership(12) == 0.0f);

    int_set su_cc_rl = set_union<fuzzy::maximum>(make_triangle<float>(4, 8, 12), make_triangle<float>(3, 7, 11));
    REQUIRE(su_cc_rl.membership(3) == 0.0f);
    REQUIRE(su_cc_rl.membership(4) == 0.25f);
    REQUIRE(su_cc_rl.membership(5) == 0.50f);
    REQUIRE(su_cc_rl.membership(6) == 0.75f);
    REQUIRE(su_cc_rl.membership(7) == 1.0f);
    REQUIRE(su_cc_rl.membership(8) == 1.0f);
    REQUIRE(su_cc_rl.membership(9) == 0.75f);
    REQUIRE(su_cc_rl.membership(10) == 0.50f);
    REQUIRE(su_cc_rl.membership(11) == 0.25f);
    REQUIRE(su_cc_rl.membership(12) == 0.0f);

    // Boundary case
    int_set su_bc_lr = set_union<fuzzy::maximum>(make_triangle<float>(4, 8, 12), make_triangle<float>(12, 16, 20));
    REQUIRE(su_bc_lr.membership(3) == 0.0f);
    REQUIRE(su_bc_lr.membership(4) == 0.0f);
    REQUIRE(su_bc_lr.membership(5) == 0.25f);
    REQUIRE(su_bc_lr.membership(11) == 0.25f);
    REQUIRE(su_bc_lr.membership(12) == 0.0f);
    REQUIRE(su_bc_lr.membership(13) == 0.25f);
    REQUIRE(su_bc_lr.membership(16) == 1.0f);
    REQUIRE(su_bc_lr.membership(20) == 0.0f);
    REQUIRE(su_bc_lr.membership(21) == 0.0f);

    // Boundaries past each-other case
    int_set su_bp_lr = set_union<fuzzy::maximum>(make_triangle<float>(-12, -8, -4), make_triangle<float>(12, 16, 20));
    REQUIRE(su_bp_lr.membership(-13) == 0.0f);
    REQUIRE(su_bp_lr.membership(-12) == 0.0f);
    REQUIRE(su_bp_lr.membership(-5) == 0.25f);
    REQUIRE(su_bp_lr.membership(-3) == 0.0f);
    REQUIRE(su_bp_lr.membership(11) == 0.0f);
    REQUIRE(su_bp_lr.membership(12) == 0.0f);
    REQUIRE(su_bp_lr.membership(16) == 1.0f);
    REQUIRE(su_bp_lr.membership(17) == 0.75f);
    REQUIRE(su_bp_lr.membership(20) == 0.0f);
    REQUIRE(su_bp_lr.membership(21) == 0.0f);

    int_set su_bp_rl = set_union<fuzzy::maximum>(make_triangle<float>(12, 16, 20), make_triangle<float>(-12, -8, -4));
    REQUIRE(su_bp_rl.membership(-13) == 0.0f);
    REQUIRE(su_bp_rl.membership(-12) == 0.0f);
    REQUIRE(su_bp_rl.membership(-5) == 0.25f);
    REQUIRE(su_bp_rl.membership(-3) == 0.0f);
    REQUIRE(su_bp_rl.membership(11) == 0.0f);
    REQUIRE(su_bp_rl.membership(12) == 0.0f);
    REQUIRE(su_bp_rl.membership(16) == 1.0f);
    REQUIRE(su_bp_rl.membership(17) == 0.75f);
    REQUIRE(su_bp_rl.membership(20) == 0.0f);
    REQUIRE(su_bp_rl.membership(21) == 0.0f);
}

TEST_CASE("SET-somewhat", "[SET_somewhat]")
{
    // Common case 
    int_set cc = somewhat(make_triangle<float>(4, 12, 20));
    REQUIRE(equivelant(cc.membership(4), 0.0f));
    REQUIRE(equivelant(cc.membership(6), 0.5f));
    REQUIRE(equivelant(cc.membership(8),0.7071069f));
    REQUIRE(equivelant(cc.membership(10), 0.8660254f));
    REQUIRE(equivelant(cc.membership(12), 1.0f));
    REQUIRE(equivelant(cc.membership(14), 0.8660254f));
    REQUIRE(equivelant(cc.membership(16), 0.7071067f));
    REQUIRE(equivelant(cc.membership(18), 0.5f));
    REQUIRE(equivelant(cc.membership(20), 0.0f));

    // Compact case
    int_set cpc = somewhat(make_triangle<float>(4, 8, 12));
    REQUIRE(equivelant(cpc.membership(4), 0.0f));
    REQUIRE(equivelant(cpc.membership(5), 0.5f));
    REQUIRE(equivelant(cpc.membership(6), 0.7071067f));
    REQUIRE(equivelant(cpc.membership(7), 0.866025f));
    REQUIRE(equivelant(cpc.membership(8), 1.0f));
    REQUIRE(equivelant(cpc.membership(9), 0.866025f));
    REQUIRE(equivelant(cpc.membership(10), 0.7071067f));
    REQUIRE(equivelant(cpc.membership(11), 0.5f));
    REQUIRE(equivelant(cpc.membership(12), 0.0f));

    // Constrained case
    int_set csc = somewhat(make_triangle<float>(4, 6, 8));
    REQUIRE(equivelant(csc.membership(4), 0.0f));
    REQUIRE(equivelant(csc.membership(5), 0.7071067f));
    REQUIRE(equivelant(csc.membership(6), 1.0f));
    REQUIRE(equivelant(csc.membership(7), 0.7071067f));
    REQUIRE(equivelant(csc.membership(8), 0.0f));

    // Extreme case
    int_set ec = somewhat(make_triangle<float>(4, 5, 6));
    REQUIRE(equivelant(ec.membership(4), 0.0f));
    REQUIRE(equivelant(ec.membership(5), 1.0f));
    REQUIRE(equivelant(ec.membership(6), 0.0f));

    // Non-uniform case.
    int_set nu = somewhat(int_set{ int_element{ 0, 0.0f },int_element{ 4, 0.25f },int_element{ 8, 0.5f },int_element{ 12, 0.75f },int_element{ 16, 0.4f },int_element{ 18, 0.0f } });
    REQUIRE(equivelant(nu.membership(0), 0.0f));
    REQUIRE(equivelant(nu.membership(4), 0.5f));
    REQUIRE(equivelant(nu.membership(8), 0.7071067f));
    REQUIRE(equivelant(nu.membership(12), 0.8660254f));
    REQUIRE(equivelant(nu.membership(16), 0.6324555f));
    REQUIRE(equivelant(nu.membership(18), 0.0f));
}

TEST_CASE("SET-very", "[SET_very]")
{
    // Common case 
    int_set cc = very(make_triangle<float>(4, 12, 20));
    REQUIRE(equivelant(cc.membership(4), 0.0f));
    REQUIRE(equivelant(cc.membership(6), 0.0625f));
    REQUIRE(equivelant(cc.membership(8), 0.25f));
    REQUIRE(equivelant(cc.membership(10), 0.5625f));
    REQUIRE(equivelant(cc.membership(12), 1.0f));
    REQUIRE(equivelant(cc.membership(14), 0.5625f));
    REQUIRE(equivelant(cc.membership(16), 0.25f));
    REQUIRE(equivelant(cc.membership(18), 0.0625f));
    REQUIRE(equivelant(cc.membership(20), 0.0f));

    // Compact case
    int_set cpc = very(make_triangle<float>(4, 8, 12));
    REQUIRE(equivelant(cpc.membership(4), 0.0f));
    REQUIRE(equivelant(cpc.membership(5), 0.0625f));
    REQUIRE(equivelant(cpc.membership(6), 0.25f));
    REQUIRE(equivelant(cpc.membership(7), 0.5625f));
    REQUIRE(equivelant(cpc.membership(8), 1.0f));
    REQUIRE(equivelant(cpc.membership(9), 0.5625f));
    REQUIRE(equivelant(cpc.membership(10), 0.25f));
    REQUIRE(equivelant(cpc.membership(11), 0.0625f));
    REQUIRE(equivelant(cpc.membership(12), 0.0f));

    // Constrained case
    int_set csc = very(make_triangle<float>(4, 6, 8));
    REQUIRE(equivelant(csc.membership(4), 0.0f));
    REQUIRE(equivelant(csc.membership(5), 0.25f));
    REQUIRE(equivelant(csc.membership(6), 1.0f));
    REQUIRE(equivelant(csc.membership(7), 0.25f));
    REQUIRE(equivelant(csc.membership(8), 0.0f));

    // Extreme case
    int_set ec = very(make_triangle<float>(4, 5, 6));
    REQUIRE(equivelant(ec.membership(4), 0.0f));
    REQUIRE(equivelant(ec.membership(5), 1.0f));
    REQUIRE(equivelant(ec.membership(6), 0.0f));

    // Non-uniform case.
    int_set nu = very(int_set{ int_element{ 0, 0.0f },int_element{ 4, 0.25f },int_element{ 8, 0.5f },int_element{ 12, 0.75f },int_element{ 16, 0.4f },int_element{ 18, 0.0f } });
    REQUIRE(equivelant(nu.membership(0), 0.0f));
    REQUIRE(equivelant(nu.membership(4), 0.0625f));
    REQUIRE(equivelant(nu.membership(8), 0.25f));
    REQUIRE(equivelant(nu.membership(12), 0.5625f));
    REQUIRE(equivelant(nu.membership(16), 0.16f));
    REQUIRE(equivelant(nu.membership(18), 0.0f));
}

#if ENABLE_DEPRECATED_TESTS
TEST_CASE("Relation", "[Relation]")
{
    int_set large = make_triangle<float>(1200, 1600, 2000);
    int_set strong = make_triangle<float>(1600, 2000, 2400);
    relation rel{ large, strong, minimum{} };

    REQUIRE(equivelant(rel.membership(1200, 1600), 0.0f));
    REQUIRE(equivelant(rel.membership(1200, 2000), 0.0f));
    REQUIRE(equivelant(rel.membership(1400, 1800), 0.5f));
    REQUIRE(equivelant(rel.membership(1600, 2000), 1.0f));
    REQUIRE(equivelant(rel.membership(1700, 1900), 0.75f));
    REQUIRE(equivelant(rel.membership(1900, 2200), 0.25f));
    REQUIRE(equivelant(rel.membership(1100, 1900), 0.0f));
}

TEST_CASE("Mapping-Rule-1", "[Mapping_Rule_1]")
{
    int_set large = make_triangle<float>(1200, 1600, 2000);
    int_set strong = make_triangle<float>(1600, 2000, 2400);
    relation rel1{ large, strong, minimum{} };
    mapping_rule rule1{ rel1, fuzzy::maximum{} };

    int_set horse_weight = make_triangle<float>(1300, 1400, 1500);
    int_set horse_strength1 = rule1.apply(horse_weight);
    REQUIRE(horse_strength1.size() == 4);
    REQUIRE(equivelant(horse_strength1.membership(1600), 0.0f));
    REQUIRE(equivelant(horse_strength1.membership(1700), 0.25f));
    REQUIRE(equivelant(horse_strength1.membership(1800), 0.5f));
    REQUIRE(equivelant(horse_strength1.membership(1900), 0.6f));
    REQUIRE(equivelant(horse_strength1.membership(2000), 0.6f));
    REQUIRE(equivelant(horse_strength1.membership(2400), 0.0f));


    int_set medium = make_triangle<float>(800, 1200, 1600);
    int_set moderate = make_triangle<float>(1200, 1600, 2000);
    relation rel2{ medium, moderate, minimum{} };
    mapping_rule rule2{ rel2, fuzzy::maximum{} };

    int_set horse_strength2 = rule2.apply(horse_weight);
    REQUIRE(horse_strength2.size() == 4);
    REQUIRE(equivelant(horse_strength2.membership(1200), 0.0f));
    REQUIRE(equivelant(horse_strength2.membership(1600), 0.6f));
    REQUIRE(equivelant(horse_strength2.membership(1700), 0.6f));
    REQUIRE(equivelant(horse_strength2.membership(1800), 0.5f));
    REQUIRE(equivelant(horse_strength2.membership(1900), 0.25f));
    REQUIRE(equivelant(horse_strength2.membership(2000), 0.0f));
}

TEST_CASE("Mapping-Rule-2", "[Mapping_Rule_2]")
{
    int_set hot = make_triangle<float>(90, 105, 120);
    int_set fast = make_triangle<float>(700, 900, 1100);
    relation rel1{ hot, fast, minimum{} };
    mapping_rule rule1{ rel1, maximum{} };

    int_set temp = make_triangle<float>(95,100,105);
    int_set fan_speed1 = rule1.apply(temp);
    REQUIRE(fan_speed1.size() == 5);
    REQUIRE(equivelant(fan_speed1.membership(700), 0.0f));
    REQUIRE(equivelant(fan_speed1.membership(833), 0.665f));
    REQUIRE(equivelant(fan_speed1.membership(847), 0.7333333f));
    REQUIRE(equivelant(fan_speed1.membership(900), 0.7333333f));
    REQUIRE(equivelant(fan_speed1.membership(1100), 0.0f));

    int_set warm = make_triangle<float>(75,90,105);
    int_set medium = make_triangle<float>(500, 700, 900);
    relation rel2{ warm, medium, minimum{} };
    mapping_rule rule2{ rel2, fuzzy::maximum{} };

    int_set fan_speed2 = rule2.apply(temp);
    REQUIRE(fan_speed2.size() == 5);
    REQUIRE(equivelant(fan_speed2.membership(500), 0.0f));
    REQUIRE(equivelant(fan_speed2.membership(700), 0.4f));
    REQUIRE(equivelant(fan_speed2.membership(793), 0.4f));
    REQUIRE(equivelant(fan_speed2.membership(833), 0.335f));
    REQUIRE(equivelant(fan_speed2.membership(900), 0.0f));
}

TEST_CASE("Scaling-Inference-Rule-1", "[Scaling_Inference_Rule_1]")
{
    int_set large = make_triangle<float>(1200, 1600, 2000);
    int_set strong = make_triangle<float>(1600, 2000, 2400);
    scaling_inference rule1{ large, fuzzy::minimum{} };

    int const horse_weight = 1400;
    int_set horse_strength1 = rule1.apply(horse_weight, strong);
    REQUIRE(horse_strength1.size() == 3);
    REQUIRE(equivelant(horse_strength1.membership(1600), 0.0f));
    REQUIRE(equivelant(horse_strength1.membership(1700), 0.25f));
    REQUIRE(equivelant(horse_strength1.membership(1800), 0.5f));
    REQUIRE(equivelant(horse_strength1.membership(2100), 0.25f));
    REQUIRE(equivelant(horse_strength1.membership(2400), 0.0f));

    int_set medium = make_triangle<float>(800, 1200, 1600);
    int_set moderate = make_triangle<float>(1200, 1600, 2000);
    scaling_inference rule2{ medium, fuzzy::minimum{} };

    int_set horse_strength2 = rule2.apply(horse_weight, moderate);
    REQUIRE(horse_strength2.size() == 3);
    REQUIRE(equivelant(horse_strength2.membership(1200), 0.0f));
    REQUIRE(equivelant(horse_strength2.membership(1500), 0.25f));
    REQUIRE(equivelant(horse_strength2.membership(1800), 0.5f));
    REQUIRE(equivelant(horse_strength2.membership(1900), 0.25f));
    REQUIRE(equivelant(horse_strength2.membership(2000), 0.0f));
}

TEST_CASE("Scaling-Inference-Rule-2", "[Scaling_Inference_Rule_2]")
{
    int_set hot = make_triangle<float>(90, 105, 120);
    int_set fast = make_triangle<float>(700, 900, 1100);
    scaling_inference rule1{ hot };

    int temp = 100;
    int_set fan_speed1 = rule1.apply(temp, fast);
    REQUIRE(fan_speed1.size() == 3);
    REQUIRE(equivelant(fan_speed1.membership(700), 0.0f));
    REQUIRE(equivelant(fan_speed1.membership(833), 0.665f));
    REQUIRE(equivelant(fan_speed1.membership(1100), 0.0f));

    int_set warm = make_triangle<float>(75, 90, 105);
    int_set medium = make_triangle<float>(500, 700, 900);
    scaling_inference rule2{ warm };

    int_set fan_speed2 = rule2.apply(temp, medium);
    REQUIRE(fan_speed2.size() == 3);
    REQUIRE(equivelant(fan_speed2.membership(500), 0.0f));
    REQUIRE(equivelant(fan_speed2.membership(833), 0.333333f));
    REQUIRE(equivelant(fan_speed2.membership(900), 0.0f));
}

#endif // ENABLE_DEPRECATED_TESTS

TEST_CASE("Consequent-1", "[Consequent_1]")
{
    
	int_maximum_aggregator cons1;
	int_set horse_strength1 = int_set{ int_element{ 1600, 0.0f },int_element{ 1900, 0.6f },int_element{ 2000, 0.6f },int_element{ 2400, 0.0f } };
	int_set horse_strength2 = int_set{ int_element{ 1200, 0.0f },int_element{ 1600, 0.6f },int_element{ 1700, 0.6f },int_element{ 2000, 0.0f } };
	cons1.aggregate(horse_strength1);
	cons1.aggregate(horse_strength2);

	int_set const& horse_strength3 = cons1.result();
	REQUIRE(equivelant(horse_strength3.membership(1200), 0.0f));
	REQUIRE(equivelant(horse_strength3.membership(1600), 0.6f));
	REQUIRE(equivelant(horse_strength3.membership(1700), 0.6f));
	REQUIRE(equivelant(horse_strength3.membership(1800), 0.4f));
	REQUIRE(equivelant(horse_strength3.membership(1900), 0.6f));
	REQUIRE(equivelant(horse_strength3.membership(2000), 0.6f));
	REQUIRE(equivelant(horse_strength3.membership(2400), 0.0f));
}

TEST_CASE("Consequent-2", "[Consequent_2]")
{
    int_maximum_aggregator cons2;
    int_set fan_speed1 = int_set{ int_element{ 700, 0.0f },int_element{ 847, 0.7333333f },int_element{ 900, 0.7333333f },int_element{ 1100, 0.0f } };
    int_set fan_speed2 = int_set{ int_element{ 500, 0.0f },int_element{ 700, 0.4f },int_element{ 793, 0.4f },int_element{ 900, 0.0f } };
    cons2.aggregate(fan_speed1);
    cons2.aggregate(fan_speed2);

    int_set const& fan_speed3 = cons2.result();
    REQUIRE(equivelant(fan_speed3.membership(500), 0.0f));
    REQUIRE(equivelant(fan_speed3.membership(700), 0.4f));
    REQUIRE(equivelant(fan_speed3.membership(780), 0.4f));
    REQUIRE(equivelant(fan_speed3.membership(793), 0.4639455f));
    REQUIRE(equivelant(fan_speed3.membership(847), 0.7333333f));
    REQUIRE(equivelant(fan_speed3.membership(900), 0.7333333f));
    REQUIRE(equivelant(fan_speed3.membership(1100), 0.0f));
}

TEST_CASE("Consequent-3", "[Consequent_3]")
{
    int_additive_aggregator cons1;
    int_set horse_strength1 = int_set{ int_element{ 1600, 0.0f },int_element{ 1700, 0.25f },int_element{ 1800, 0.5f },int_element{ 2100, 0.25f },int_element{ 2400, 0.0f } };
    int_set horse_strength2 = int_set{ int_element{ 1200, 0.0f },int_element{ 1500, 0.25f },int_element{ 1800, 0.5f },int_element{ 1900, 0.25f },int_element{ 2000, 0.0f } };
    cons1.aggregate(horse_strength1);
    cons1.aggregate(horse_strength2);

    int_set const& horse_strength3 = cons1.result();
    REQUIRE(equivelant(horse_strength3.membership(1200), 0.0f));
    REQUIRE(equivelant(horse_strength3.membership(1600), 0.33333333f));
    REQUIRE(equivelant(horse_strength3.membership(1700), 0.66666666f));
    REQUIRE(equivelant(horse_strength3.membership(1800), 1.0f));
    REQUIRE(equivelant(horse_strength3.membership(1900), 0.66666666f));
    REQUIRE(equivelant(horse_strength3.membership(2000), 0.33333333f));
    REQUIRE(equivelant(horse_strength3.membership(2400), 0.0f));
}

TEST_CASE("Consequent-4", "[Consequent_4]")
{
    int_additive_aggregator cons2;
    int_set fan_speed1 = int_set{ int_element{ 700, 0.0f },int_element{ 847, 0.7333333f },int_element{ 900, 0.7333333f },int_element{ 1100, 0.0f } };
    int_set fan_speed2 = int_set{ int_element{ 500, 0.0f },int_element{ 700, 0.4f },int_element{ 793, 0.4f },int_element{ 900, 0.0f } };
    cons2.aggregate(fan_speed1);
    cons2.aggregate(fan_speed2);

    int_set const& fan_speed3 = cons2.result();
    REQUIRE(equivelant(fan_speed3.membership(500), 0.0f));
    REQUIRE(equivelant(fan_speed3.membership(700), 0.4f));
    REQUIRE(equivelant(fan_speed3.membership(780), 0.7990930f));
    REQUIRE(equivelant(fan_speed3.membership(793), 0.86394556f));
    REQUIRE(equivelant(fan_speed3.membership(847), 0.931464f));
    REQUIRE(equivelant(fan_speed3.membership(900), 0.7333333f));
    REQUIRE(equivelant(fan_speed3.membership(1100), 0.0f));
}

TEST_CASE("Scaled-Antecedent", "[Scaled_Antecedent]")
{
    using namespace fuzzy::functions::minimum;

    int_set fan_speed1 = int_set{ int_element{ 650, 0.0f },int_element{ 700, 1.0f },int_element{ 750, 0.0f }};
    int_set fan_speed2 = int_set{ int_element{ 750, 0.0f },int_element{ 800, 1.0f },int_element{ 850, 0.0f } };
    int_set fast = int_set{ int_element{ 700, 0.0f },int_element{ 900, 1.0f },int_element{ 1100, 0.0f } };

    auto sa1 = is(fan_speed1,fast);
    REQUIRE(sa1.set().size() == 3u);
    REQUIRE(equivelant(sa1.set().membership(0.0f), 0.0f));
    REQUIRE(equivelant(sa1.set().membership(0.1f), 0.2f));
    REQUIRE(equivelant(sa1.set().membership(1.0f), 0.0f));

    auto sa2 = is(fan_speed2,fast);
    REQUIRE(sa2.set().size() == 3u);
    REQUIRE(equivelant(sa2.set().membership(0.0f), 0.0f));
    REQUIRE(equivelant(sa2.set().membership(0.3f), 0.6f));
    REQUIRE(equivelant(sa2.set().membership(1.f), 0.0f));
}

TEST_CASE("Result-Aggregator", "[Result_Aggregator]")
{
    int_additive_aggregator fan_speed;

    int_set fast = int_set{ int_element{ 700, 0.0f },int_element{ 900, 1.0f },int_element{ 1100, 0.0f } };
    auto consequent = fan_speed.shall_be(fast);

    REQUIRE(&consequent.target() == &fast);
    REQUIRE(&consequent.aggregator() == &fan_speed);
    REQUIRE(consequent.aggregator().result().empty());
}

TEST_CASE("Scaled-Mapping", "[Scaled_Mapping]")
{
    using namespace fuzzy::functions::minimum;

    additive_aggregator fan_speed;
    set tempurature = set{ element{ 72.0f, 0.0f },element{ 78.0f, 1.0f },element{ 84.0f, 0.0f } };
    set warm = set{ element{ 70.0f, 0.0f },element{ 85.0f, 1.0f },element{ 100.0f, 0.0f } };
    auto sa1 = is(tempurature, warm);
    REQUIRE(sa1.set().size() == 3u);
    REQUIRE(equivelant(sa1.set().membership(0.0f), 0.0f));
    REQUIRE(equivelant(sa1.set().membership(0.3333333f), 0.6666667f));
    REQUIRE(equivelant(sa1.set().membership(1.0f), 0.0f));

    set fast = set{ element{ 700.0f, 0.0f }, element{ 900.0f, 1.0f }, element{ 1100.0f, 0.0f } };
    auto consequent = fan_speed.shall_be(fast);
    fuzzy::scaled_mapping<fuzzy::minimum>(sa1, consequent);
    REQUIRE(&consequent.target() == &fast);
    REQUIRE(&consequent.aggregator() == &fan_speed);
    REQUIRE(consequent.aggregator().result().size() == 3);
    REQUIRE(equivelant(consequent.aggregator().result().membership(700.0f), 0.0f));
    REQUIRE(equivelant(consequent.aggregator().result().membership(833.333374f), 0.666666f));
    REQUIRE(equivelant(consequent.aggregator().result().membership(900.00f), 0.500000f));
    REQUIRE(equivelant(consequent.aggregator().result().membership(1100.0f), 0.0f));
}

TEST_CASE("Opperators_And_Functions", "[Opperators-And-Functions]")
{
    using namespace fuzzy;

    set const medium = make_triangle<float>(800.0f, 1000.0f, 1200.0f);
    set const mild = make_triangle<float>(55.0f, 70.0f, 85.0f);
    set const warm = make_triangle<float>(70.0f, 85.0f, 100.0f);
    set const t0 = make_triangle<float>(72.0f, 78.0f, 84.0f);

    // t-norm
    {
        using namespace operators::algabraic;
        using namespace functions::algabraic_product;

        auto s0 = mild & warm;
        REQUIRE(s0.size() == 3u);
        REQUIRE(equivelant(s0.membership(75.0f), 0.166667f));

        auto a0 = is(t0, mild) & is(t0, warm);
        REQUIRE(a0.set().size() == 11u);
        REQUIRE(equivelant(a0.set().membership(0.545699f), 0.0917287f));

        additive_aggregator fan_speed;
        is(t0, warm) >> fan_speed.shall_be(medium);
        REQUIRE(fan_speed.result().size() == 6);
        REQUIRE(equivelant(fan_speed.result().membership(1000.0f), 0.333333f));
    }
    {
        using namespace operators::bounded;
        using namespace functions::bounded_difference;

        auto s0 = mild & warm;
        REQUIRE(s0.size() == 0u);
        REQUIRE(equivelant(s0.membership(75.0f), 0.0f));

        auto a0 = is(t0, mild) & is(t0, warm);
        REQUIRE(a0.set().size() == 0u);
        REQUIRE(equivelant(a0.set().membership(0.5272727f), 0.0f));

        additive_aggregator fan_speed;
        is(t0, warm) >> fan_speed.shall_be(medium);
        REQUIRE(fan_speed.result().size() == 5);
        REQUIRE(equivelant(fan_speed.result().membership(1000.0f), 0.25f));
    }
    {
        using namespace operators::drastic;
        using namespace functions::drastic_product;

        auto s0 = mild & warm;
        REQUIRE(s0.size() == 0u);
        REQUIRE(equivelant(s0.membership(75.0f), 0.0f));

        auto a0 = is(t0, mild) & is(t0, warm);
        REQUIRE(a0.set().size() == 0u);
        REQUIRE(equivelant(a0.set().membership(0.5272727f), 0.0f));

        additive_aggregator fan_speed;
        is(t0, warm) >> fan_speed.shall_be(medium);
        REQUIRE(fan_speed.result().size() == 3);
        REQUIRE(equivelant(fan_speed.result().membership(1000.0f), 0.363636f));
    }
    {
        using namespace operators::einstein;
        using namespace functions::einstein_product;

        auto s0 = mild & warm;
        REQUIRE(s0.size() == 3u);
        REQUIRE(equivelant(s0.membership(75.0f), 0.133333f));

        auto a0 = is(t0, mild) & is(t0, warm);
        REQUIRE(a0.set().size() == 11u);
        REQUIRE(equivelant(a0.set().membership(0.553163f), 0.0468059f));

        additive_aggregator fan_speed;
        is(t0, warm) >> fan_speed.shall_be(medium);
        REQUIRE(fan_speed.result().size() == 6);
        REQUIRE(equivelant(fan_speed.result().membership(1000.0f), 0.3f));
    }
    {
        using namespace operators::hamacher;
        using namespace functions::hamacher_product;

        auto s0 = mild & warm;
        REQUIRE(s0.size() == 3u);
        REQUIRE(equivelant(s0.membership(75.0f), 0.222222f));

        auto a0 = is(t0, mild) & is(t0, warm);
        REQUIRE(a0.set().size() == 9u);
        REQUIRE(equivelant(a0.set().membership(0.53601f), 0.210648f));

        additive_aggregator fan_speed;
        is(t0, warm) >> fan_speed.shall_be(medium);
        REQUIRE(fan_speed.result().size() == 6);
        REQUIRE(equivelant(fan_speed.result().membership(1000.0f), 0.375f));
    }
    {
        using namespace operators::minmax;
        using namespace functions::minimum;

        auto s0 = mild & warm;
        REQUIRE(s0.size() == 3u);
        REQUIRE(equivelant(s0.membership(75.0f), 0.333333f));

        auto a0 = is(t0, mild) & is(t0, warm);
        REQUIRE(a0.set().size() == 3u);
        REQUIRE(equivelant(a0.set().membership(0.5272727f), 0.472727f));

        additive_aggregator fan_speed;
        is(t0, warm) >> fan_speed.shall_be(medium);
        REQUIRE(fan_speed.result().size() == 3);
        REQUIRE(equivelant(fan_speed.result().membership(1000.0f), 0.5f));
    }

    // t-conorm
    {
        using namespace operators::tconorm::algabraic_sum;
        using namespace functions::minimum;

        auto s0 = mild | warm;
        REQUIRE(s0.size() == 5u);
        REQUIRE(equivelant(s0.membership(75.0f), 0.833333f));

        auto a0 = is(t0, mild) | is(t0, warm);
        REQUIRE(a0.set().size() == 5u);
        REQUIRE(equivelant(a0.set().membership(0.5272727f), 0.721983f));
    }
    {
        using namespace operators::tconorm::bounded_sum;
        using namespace functions::minimum;

        auto s0 = mild | warm;
        REQUIRE(s0.size() == 4u);
        REQUIRE(equivelant(s0.membership(75.0f), 1.0f));

        auto a0 = is(t0, mild) | is(t0, warm);
        REQUIRE(a0.set().size() == 4u);
        REQUIRE(equivelant(a0.set().membership(0.5272727f), 0.945454f));
    }
    {
        using namespace operators::tconorm::drastic_sum;
        using namespace functions::minimum;

        auto s0 = mild | warm;
        REQUIRE(s0.size() == 4u);
        REQUIRE(equivelant(s0.membership(75.0f), 1.0f));

        auto a0 = is(t0, mild) | is(t0, warm);
        REQUIRE(a0.set().size() == 4u);
        REQUIRE(equivelant(a0.set().membership(0.5272727f), 1.0f));
    }
    {
        using namespace operators::tconorm::einstein_sum;
        using namespace functions::minimum;

        auto s0 = mild | warm;
        REQUIRE(s0.size() == 5u);
        REQUIRE(equivelant(s0.membership(75.0f), 0.866666f));

        auto a0 = is(t0, mild) | is(t0, warm);
        REQUIRE(a0.set().size() == 5u);
        REQUIRE(equivelant(a0.set().membership(0.5272727f), 0.772764f));
    }
    {
        using namespace operators::tconorm::hamacher_sum;
        using namespace fuzzy::functions::minimum;

        auto s0 = mild | warm;
        REQUIRE(s0.size() == 5u);
        REQUIRE(equivelant(s0.membership(75.0f), 0.777777f));

        auto a0 = is(t0, mild) | is(t0, warm);
        REQUIRE(a0.set().size() == 5u);
        REQUIRE(equivelant(a0.set().membership(0.5272727f), 0.641975f));
    }
    {
        using namespace operators::tconorm::maximum;
        using namespace fuzzy::functions::minimum;

        auto s0 = mild | warm;
        REQUIRE(s0.size() == 5u);
        REQUIRE(equivelant(s0.membership(75.0f), 0.666667f));

        auto a0 = is(t0, mild) | is(t0, warm);
        REQUIRE(a0.set().size() == 5u);
        REQUIRE(equivelant(a0.set().membership(0.5272727f), 0.472727f));
    }
}

TEST_CASE("Deffuzification", "[Deffuzification]")
{
    {
        set const aset{};
        REQUIRE(equivelant(mean_of_maximum(aset), std::numeric_limits<float>::max()));
        REQUIRE(equivelant(mean_of_maximum_nearest_maxima(aset), std::numeric_limits<float>::max()));
        REQUIRE(equivelant(center_of_area(aset), std::numeric_limits<float>::max()));
    }
    {
        set const aset{ { 42.0f, 0.96f } };
        REQUIRE(equivelant(mean_of_maximum(aset), 42.0f));
        REQUIRE(equivelant(mean_of_maximum_nearest_maxima(aset), 42.0f));
        REQUIRE(equivelant(center_of_area(aset), 42.0f));
    }
    {
        set const aset = make_triangle<float>(55.0f, 70.0f, 85.0f);
        REQUIRE(equivelant(mean_of_maximum(aset), 70.0f));
        REQUIRE(equivelant(mean_of_maximum_nearest_maxima(aset), 70.0f));
        REQUIRE(equivelant(center_of_area(aset), 70.0f));
    }
    {
        set const aset{ {50.0f, 0.0f}, {60.0f, 1.0f}, { 70.0f, 1.0f }, { 80.0f, 0.0f } };
        REQUIRE(equivelant(mean_of_maximum(aset), 65.0f));
        REQUIRE(equivelant(mean_of_maximum_nearest_maxima(aset), 65.0f));
        REQUIRE(equivelant(center_of_area(aset), 65.0f));
    }
    {
        set const aset{ {50.0f, 0.0f}, {60.0f, 1.0f}, { 70.0f, 1.0f }, { 80.0f, 0.0f }, { 90.0f, 0.0f }, { 100.0f, 1.0f }, { 110.0f, 1.0f }, { 120.0f, 0.0f } };
        REQUIRE(equivelant(mean_of_maximum(aset), 85.0f));
        REQUIRE(equivelant(mean_of_maximum_nearest_maxima(aset), 100.0f));
        REQUIRE(equivelant(center_of_area(aset), 85.0f));
    }
    {
        set const aset{ {40.0f, 0.0f}, {50.0f, 1.0f}, { 70.0f, 1.0f }, { 80.0f, 0.0f }, { 90.0f, 0.0f }, { 100.0f, 1.0f }, { 110.0f, 1.0f }, { 120.0f, 0.0f } };
        REQUIRE(equivelant(mean_of_maximum(aset), 75.46875f));
        REQUIRE(equivelant(mean_of_maximum_nearest_maxima(aset), 70.0f));
        REQUIRE(equivelant(center_of_area(aset), 78.0f));
    }
}

TEST_CASE("Expressions", "[Expressions]")
{
	using namespace fuzzy;

	set const mild = make_triangle<float>(55.0f, 70.0f, 85.0f);
	set const warm = make_triangle<float>(70.0f, 85.0f, 100.0f);
	set const t0 = make_triangle<float>(72.0f, 78.0f, 84.0f);

	set const humid{ {50.0f, 0.0f}, {80.0f, 1.0f}, { 100.0f, 1.0f } };
    set const h0 = make_triangle<float>(62.0f, 68.0f, 74.0f);

	set const slow = make_triangle<float>(600.0f, 900.0f, 1200.0f);
	set const medium = make_triangle<float>(900.0f, 1200.0f, 1500.0f);
    set const fast = make_triangle<float>(1200.0f, 1500.0f, 1800.0f);
    set const very_fast = very(fast);
    set const not_slow = ~slow;
	{
		using namespace fuzzy::models::mamdani;
		aggregator speed;

		(is(t0, mild) | is(h0, somewhat(humid))) >> speed.shall_be(slow);
		(is(t0, warm) & is(h0, humid)) >> speed.shall_be(very_fast);
        (is(t0, warm) | is(h0, somewhat(humid))) >> speed.shall_be(medium);

        REQUIRE(speed.result().size() == 17u);
        auto itr = speed.result().begin();
        REQUIRE(equivelant(itr->value(), 600.0f));
        REQUIRE(equivelant(itr->membership(), 0.0f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 900.0f));
        REQUIRE(equivelant(itr->membership(), 0.673364f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 928.472778f));
        REQUIRE(equivelant(itr->membership(), 0.737272f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 966.675964f));
        REQUIRE(equivelant(itr->membership(), 0.777746f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 1050.0f));
        REQUIRE(equivelant(itr->membership(), 0.499999f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 1100.0f));
        REQUIRE(equivelant(itr->membership(), 0.666666f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 1155.67517f));
        REQUIRE(equivelant(itr->membership(), 0.573874f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 1200.0f));
        REQUIRE(equivelant(itr->membership(), 0.673364f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 1228.47278f));
        REQUIRE(equivelant(itr->membership(), 0.737272f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 1266.67603f));
        REQUIRE(equivelant(itr->membership(), 0.777746f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 1275.0f));
        REQUIRE(equivelant(itr->membership(), 0.75f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 1350.0f));
        REQUIRE(equivelant(itr->membership(), 0.5f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 1383.33337f));
        REQUIRE(equivelant(itr->membership(), 0.388889f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 1425.0f));
        REQUIRE(equivelant(itr->membership(), 0.5625f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 1426.15381f));
        REQUIRE(equivelant(itr->membership(), 0.569230f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 1500.0f));
        REQUIRE(equivelant(itr->membership(), 0.428571f));
        ++itr;
        REQUIRE(equivelant(itr->value(), 1725.0f));
        REQUIRE(equivelant(itr->membership(), 0.0f));
    }
}

TEST_CASE("Final", "[Final]")
{
    using namespace fuzzy;

    constexpr auto control_loop = [](float indoor_tempurature, float outdoor_tempurature)
    {

        set const cold{ {-60.0f, 1.0f}, {40.0f, 1.0f}, {45.0f, 0.0f } };
        set const chilly = make_triangle<float>(40.0f, 45.0f, 50.0f);
        set const cool = make_triangle<float>(45.0f, 50.0f, 55.0f);
        set const warm{ {50.0f, 0.0f}, {55.0f, 1.0f}, {130.0f, 1.0f } };
        set const less_than_warm = [&]()
        {
            using namespace fuzzy::operators::tconorm::bounded_sum;
            return cold | chilly | cool;
        }();
        set const more_than_chilly = [&]()
        {
            using namespace fuzzy::operators::tconorm::bounded_sum;
            return cool | warm;
        }();

        set const off{ {0.0f, 1.0f}, {0.5f, 0.0f} };
        set const slow = make_triangle<float>(4.5f, 5.0f, 8.5f);
        set const medium = make_triangle<float>(5.0f, 8.5f, 12.0f);
        set const fast{ {8.5f, 0.0f}, {12.0f, 1.0f}, {12.5f, 1.0f} };

        set const it = make_value<float>(indoor_tempurature);
        set const ot = make_value<float>(outdoor_tempurature);

        using namespace fuzzy::models::tsk;
        aggregator fan_voltage;

        //is(it, cold) >> fan_voltage.shall_be(off);
        //(is(it, cool) & is(ot, cold)) >> fan_voltage.shall_be(slow);
        //(is(it, cool) & is(ot, chilly)) >> fan_voltage.shall_be(medium);
        auto i = is(it, warm);
        auto j = is(ot, less_than_warm);
        //(is(it, warm) & is(ot, less_than_warm)) >> fan_voltage.shall_be(fast);
        i >> fan_voltage.shall_be(fast);
        //(is(it, chilly) & is(ot, more_than_chilly)) >> fan_voltage.shall_be(off);

        return center_of_area(fan_voltage.result());
    };

    //auto v0 = control_loop(42.0f, 57.0f);
    //REQUIRE(equivelant(v0, 0.23286f));

    auto v1 = control_loop(57.0f, 44.0f);
    REQUIRE(equivelant(v1, 10.618526f));

    // FIXME: Run two series here to CSV to the output (console!)
}

