//  Copyright (c) 2025, Ben McCart
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.

#include "../include/fuzzy.hpp"
#include "./test.hpp"

using namespace fuzzy;
using fuzzy::math::equivelant;
using int_element = basic_element<int, float>;
using element = basic_element<float, float>;

constexpr bool equivelant(int_element const& lhs, int_element const& rhs)
{
    return lhs.value() == rhs.value() && equivelant(lhs.membership(), rhs.membership());
}

constexpr bool equivelant(element const& lhs, element const& rhs)
{
    return equivelant(lhs.value(), rhs.value()) && equivelant(lhs.membership(), rhs.membership());
}

class file_line_exception
{
public:
    constexpr file_line_exception(const char* file, int line) noexcept
        : file_(file), line_(line)
    {}

    const char* what() const noexcept
    {
        return "Assertion failed";
    }

    const char* file() const noexcept { return file_; }
    int line() const noexcept { return line_; }

private:
    const char* file_;
    int line_;
};

#define REQUIRE( ... )           \
    do {                                \
        if (!( __VA_ARGS__ ))                    \
            throw file_line_exception(__FILE__, __LINE__); \
    } while (0)


//////////// BEGIN TESTS ///////////

constexpr bool membership_bounds_check()
{
    [[maybe_unused]] constexpr auto v0 = algabraic_product<>::apply(1.0f, 1.0f);
    [[maybe_unused]] constexpr auto v1 = algabraic_product<>::apply(0.0f, 0.0f);
    // FAIL constexpr auto v2 = algabraic_product<>::apply(-0.01f, 1.0f);
    // FAIL constexpr auto v0 = algabraic_product<>::apply(1.01f, 1.0f);

    validate_range(0.0);
    validate_range(0.5);
    validate_range(1.0);
    // FAIL validate_range(-0.00001);
    // FAIL validate_range( 1.00001);

    return true;
}

constexpr bool t_norm_tests()
{
    REQUIRE(algabraic_product<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(algabraic_product<>::apply(0.00f, 0.50f) == 0.00f);
    REQUIRE(algabraic_product<>::apply(0.00f, 1.00f) == 0.00f);
    REQUIRE(algabraic_product<>::apply(0.50f, 1.00f) == 0.50f);
    REQUIRE(algabraic_product<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(algabraic_product<>::apply(0.50f, 0.50f) == 0.25f);

    REQUIRE(bounded_difference<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(bounded_difference<>::apply(0.00f, 0.50f) == 0.00f);
    REQUIRE(bounded_difference<>::apply(0.00f, 1.00f) == 0.00f);
    REQUIRE(bounded_difference<>::apply(0.50f, 1.00f) == 0.50f);
    REQUIRE(bounded_difference<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(bounded_difference<>::apply(0.50f, 0.50f) == 0.00f);
    REQUIRE(bounded_difference<>::apply(0.75f, 0.75f) == 0.50f);

    REQUIRE(drastic_product<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(drastic_product<>::apply(0.00f, 0.50f) == 0.00f);
    REQUIRE(drastic_product<>::apply(0.00f, 1.00f) == 0.00f);
    REQUIRE(drastic_product<>::apply(0.50f, 1.00f) == 0.50f);
    REQUIRE(drastic_product<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(drastic_product<>::apply(0.50f, 0.50f) == 0.00f);

    REQUIRE(einstein_product<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(einstein_product<>::apply(0.00f, 0.50f) == 0.00f);
    REQUIRE(einstein_product<>::apply(0.00f, 1.00f) == 0.00f);
    REQUIRE(einstein_product<>::apply(0.50f, 1.00f) == 0.50f);
    REQUIRE(einstein_product<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(einstein_product<>::apply(0.50f, 0.50f) == 0.20f);

    REQUIRE(hamacher_product<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(hamacher_product<>::apply(0.00f, 0.50f) == 0.00f);
    REQUIRE(hamacher_product<>::apply(0.00f, 1.00f) == 0.00f);
    REQUIRE(hamacher_product<>::apply(0.50f, 1.00f) == 0.50f);
    REQUIRE(hamacher_product<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(hamacher_product<>::apply(0.50f, 0.50f) == 0.33333333f);

    REQUIRE(minimum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(minimum<>::apply(0.00f, 0.50f) == 0.00f);
    REQUIRE(minimum<>::apply(0.00f, 1.00f) == 0.00f);
    REQUIRE(minimum<>::apply(0.50f, 1.00f) == 0.50f);
    REQUIRE(minimum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(minimum<>::apply(0.50f, 0.50f) == 0.50f);

    return true;
}



constexpr bool t_conorm_tests()
{
    REQUIRE(algabraic_sum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(algabraic_sum<>::apply(0.00f, 0.50f) == 0.50f);
    REQUIRE(algabraic_sum<>::apply(0.00f, 1.00f) == 1.00f);
    REQUIRE(algabraic_sum<>::apply(0.50f, 1.00f) == 1.00f);
    REQUIRE(algabraic_sum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(algabraic_sum<>::apply(0.50f, 0.50f) == 0.75f);

    REQUIRE(bounded_sum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(bounded_sum<>::apply(0.00f, 0.50f) == 0.50f);
    REQUIRE(bounded_sum<>::apply(0.00f, 1.00f) == 1.00f);
    REQUIRE(bounded_sum<>::apply(0.50f, 1.00f) == 1.00f);
    REQUIRE(bounded_sum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(bounded_sum<>::apply(0.50f, 0.50f) == 1.00f);
    REQUIRE(bounded_sum<>::apply(0.25f, 0.25f) == 0.50f);

    REQUIRE(drastic_sum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(drastic_sum<>::apply(0.00f, 0.50f) == 0.50f);
    REQUIRE(drastic_sum<>::apply(0.00f, 1.00f) == 1.00f);
    REQUIRE(drastic_sum<>::apply(0.50f, 1.00f) == 1.00f);
    REQUIRE(drastic_sum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(drastic_sum<>::apply(0.50f, 0.50f) == 1.00f);

    REQUIRE(einstein_sum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(einstein_sum<>::apply(0.00f, 0.50f) == 0.50f);
    REQUIRE(einstein_sum<>::apply(0.00f, 1.00f) == 1.00f);
    REQUIRE(einstein_sum<>::apply(0.50f, 1.00f) == 1.00f);
    REQUIRE(einstein_sum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(einstein_sum<>::apply(0.50f, 0.50f) == 0.80f);

    REQUIRE(hamacher_sum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(hamacher_sum<>::apply(0.00f, 0.50f) == 0.50f);
    REQUIRE(hamacher_sum<>::apply(0.00f, 1.00f) == 1.00f);
    REQUIRE(hamacher_sum<>::apply(0.50f, 1.00f) == 1.00f);
    REQUIRE(hamacher_sum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(hamacher_sum<>::apply(0.50f, 0.50f) == 0.66666666f);

    REQUIRE(maximum<>::apply(0.00f, 0.00f) == 0.00f);
    REQUIRE(maximum<>::apply(0.00f, 0.50f) == 0.50f);
    REQUIRE(maximum<>::apply(0.00f, 1.00f) == 1.00f);
    REQUIRE(maximum<>::apply(0.50f, 1.00f) == 1.00f);
    REQUIRE(maximum<>::apply(1.00f, 1.00f) == 1.00f);
    REQUIRE(maximum<>::apply(0.50f, 0.50f) == 0.50f);

    return true;
}

constexpr bool basic_element_tests()
{
    int_element e1{ 1, 1.0f };
    REQUIRE(e1.membership() == 1.0f);
    REQUIRE(e1.value() == 1);

    int_element e0{ 0, 0.0f };
    REQUIRE(e0.membership() == 0.0f);
    REQUIRE(e0.value() == 0);
    REQUIRE(e0 < e1);

    int_element eol{ 3, 0.4f };
    int_element eor{ 5, 0.4f };
    int_element ea = [](int_element const l, int_element const r) constexpr
    {
        return int_element{ l.value() + r.value(), l.membership() + r.membership() };
    }(eol, eor);
    REQUIRE(ea.value() == 8);
    REQUIRE(ea.membership() == 0.8f);

    REQUIRE(eol == int_element{ 3, 0.4f });
    REQUIRE(eol != int_element{ 3, 0.3999f });
    REQUIRE(eol != int_element{ -3, 0.4f });

    int_element ec{ e1 };
    REQUIRE(ec == e1);
    REQUIRE(ec != e0);
    ec = e0;
    REQUIRE(ec != e1);
    REQUIRE(ec == e0);

    int_element em{ std::move(ec) };
    REQUIRE(em == int_element{ 0, 0.0f });
    REQUIRE(em != int_element{ 1, 1.0f });

    em = int_element{ 2, 0.2f };
    REQUIRE(em == int_element{ 2, 0.2f });
    REQUIRE(em != int_element{ 2, 0.1f });

    // FAIL int_element em1{ -1, -1.0f };
    // FAIL int_element em1{ -1, -1.0001f };
    // FAIL int_element einf{ 1, std::numeric_limits<float>::infinity() };
    // FAIL int_element eninf{ -1, -std::numeric_limits<float>::infinity() };

    return true;
}

constexpr bool empty_int_set()
{
    int_set empty;
    REQUIRE(empty.empty());
    REQUIRE(empty.size() == 0u);
    REQUIRE(all_ranges_valid(empty));

    return true;
}

constexpr bool one_int_element_int_set()
{
    int_set s1 = { {3, 1.0f} };
    REQUIRE(!s1.empty());
    REQUIRE(s1.size() == 1u);
    REQUIRE(all_ranges_valid(s1));

    return true;
}

constexpr bool two_int_element_int_set()
{
    int_set s2 = { {3, 1.0f}, {5, 1.0f} };
    REQUIRE(!s2.empty());
    REQUIRE(s2.size() == 2u);
    REQUIRE(all_ranges_valid(s2));

    return true;
}

constexpr bool int_set_equivalence()
{
    int_set s1 = { {3, 1.0f}, {5, 1.0f} };
    int_set s2 = { {3, 1.0f}, {5, 1.0f} };
    REQUIRE(s1 == s2);
    REQUIRE(s1 == int_set{ { {3, 1.0f}, { 5, 1.0f } } });
    REQUIRE(s1 != int_set{ { {3, 1.0f} } });
    REQUIRE(s1 != int_set{ { { 5, 1.0f } } });
    REQUIRE(s1 != int_set{ { {3, 0.999f}, { 5, 1.0f } } });
    REQUIRE(s1 != int_set{ { {3, 1.0f}, { 5, 0.999f } } });
    REQUIRE(s1 != int_set{ { {4, 1.0f}, { 5, 1.0f } } });
    REQUIRE(s1 != int_set{ { {3, 1.0f}, { 4, 1.0f } } });

    return true;
}

constexpr bool int_set_copy_construct()
{
    int_set s1 = { {3, 1.0f}, {5, 1.0f} };
    int_set s2{ s1 };
    REQUIRE(!s2.empty());
    REQUIRE(s2.size() == 2u);
    REQUIRE(all_ranges_valid(s2));
    REQUIRE(s2 == s1);

    REQUIRE(s2 != int_set{ { {3, 0.0f}, { 4, 1.0f } } });

    return true;
}

constexpr bool int_set_move_construct()
{
    int_set s1 = { {3, 1.0f}, {5, 1.0f} };
    int_set s2{ std::move(s1) };
    REQUIRE(!s2.empty());
    REQUIRE(s2.size() == 2u);
    REQUIRE(all_ranges_valid(s2));
    REQUIRE(s1.empty());
    REQUIRE(s2 == int_set{ { {3, 1.0f}, { 5, 1.0f } } });

    return true;
}

constexpr bool int_set_assignment()
{
    int_set s1 = { {3, 1.0f}, {5, 1.0f} };
    int_set s2;
    s2 = s1;
    REQUIRE(!s2.empty());
    REQUIRE(s2.size() == 2u);
    REQUIRE(all_ranges_valid(s2));
    REQUIRE(s2 == int_set{ { {3, 1.0f}, { 5, 1.0f } } });

    int_set s3;
    s3 = std::move(s1);
    REQUIRE(!s3.empty());
    REQUIRE(s3.size() == 2u);
    REQUIRE(all_ranges_valid(s3));
    REQUIRE(s3 == int_set{ { {3, 1.0f}, { 5, 1.0f } } });

    int_set s4;
    s4 = { {3, 1.0f}, { 5, 1.0f } };
    REQUIRE(!s4.empty());
    REQUIRE(s4.size() == 2u);
    REQUIRE(all_ranges_valid(s4));
    REQUIRE(s4 == int_set{ { {3, 1.0f}, { 5, 1.0f } } });

    return true;
}

constexpr bool int_set_lowerbound()
{
    int_set s = { {3, 1.0f}, {5, 0.8f} };

    // lb on keys
    REQUIRE(*s.lower_bound(0) == int_element{ 3, 1.0f });
    REQUIRE(*s.lower_bound(3) == int_element{ 3, 1.0f });
    REQUIRE(*s.lower_bound(4) == int_element{ 5, 0.8f });
    REQUIRE(*s.lower_bound(5) == int_element{ 5, 0.8f });
    REQUIRE(s.lower_bound(6) == s.end());

    // lb on elements
    REQUIRE(*s.lower_bound(int_element{ 1, 0.0f }) == int_element{ 3, 1.0f });
    REQUIRE(*s.lower_bound(int_element{ 3, 0.7f }) == int_element{ 3, 1.0f });
    REQUIRE(*s.lower_bound(int_element{ 4, 1.0f }) == int_element{ 5, 0.8f });
    REQUIRE(*s.lower_bound(int_element{ 5, 0.8f }) == int_element{ 5, 0.8f });
    REQUIRE(s.lower_bound(int_element{ 6, 0.0f }) == s.end());

    int_set const cs = { {3, 1.0f}, {5, 0.8f} };

    // lb on keys
    REQUIRE(*cs.lower_bound(0) == int_element{ 3, 1.0f });
    REQUIRE(*cs.lower_bound(3) == int_element{ 3, 1.0f });
    REQUIRE(*cs.lower_bound(4) == int_element{ 5, 0.8f });
    REQUIRE(*cs.lower_bound(5) == int_element{ 5, 0.8f });
    REQUIRE(cs.lower_bound(6) == cs.end());

    // lb on elements
    REQUIRE(*cs.lower_bound(int_element{ 1, 0.0f }) == int_element{ 3, 1.0f });
    REQUIRE(*cs.lower_bound(int_element{ 3, 0.7f }) == int_element{ 3, 1.0f });
    REQUIRE(*cs.lower_bound(int_element{ 4, 1.0f }) == int_element{ 5, 0.8f });
    REQUIRE(*cs.lower_bound(int_element{ 5, 0.8f }) == int_element{ 5, 0.8f });
    REQUIRE(cs.lower_bound(int_element{ 6, 0.0f }) == cs.end());

    return true;
}

constexpr bool int_set_upperbound()
{
    int_set s = { {3, 1.0f}, {5, 0.8f} };

    // ub on keys
    REQUIRE(*s.upper_bound(0) == int_element{ 3, 1.0f });
    REQUIRE(*s.upper_bound(3) == int_element{ 5, 0.8f });
    REQUIRE(*s.upper_bound(4) == int_element{ 5, 0.8f });
    REQUIRE(s.upper_bound(5) == s.end());
    REQUIRE(s.upper_bound(6) == s.end());

    // ub on elements
    REQUIRE(*s.upper_bound(int_element{ 1, 0.0f }) == int_element{ 3, 1.0f });
    REQUIRE(*s.upper_bound(int_element{ 3, 0.7f }) == int_element{ 5, 0.8f });
    REQUIRE(*s.upper_bound(int_element{ 4, 1.0f }) == int_element{ 5, 0.8f });
    REQUIRE(s.upper_bound(int_element{ 5, 0.8f }) == s.end());
    REQUIRE(s.upper_bound(int_element{ 6, 0.0f }) == s.end());

    int_set const cs = { {3, 1.0f}, {5, 0.8f} };

    // ub on keys
    REQUIRE(*cs.upper_bound(0) == int_element{ 3, 1.0f });
    REQUIRE(*cs.upper_bound(3) == int_element{ 5, 0.8f });
    REQUIRE(*cs.upper_bound(4) == int_element{ 5, 0.8f });
    REQUIRE(cs.upper_bound(5) == cs.end());
    REQUIRE(cs.upper_bound(6) == cs.end());

    // ub on elements
    REQUIRE(*cs.upper_bound(int_element{ 1, 0.0f }) == int_element{ 3, 1.0f });
    REQUIRE(*cs.upper_bound(int_element{ 3, 0.7f }) == int_element{ 5, 0.8f });
    REQUIRE(*cs.upper_bound(int_element{ 4, 1.0f }) == int_element{ 5, 0.8f });
    REQUIRE(cs.upper_bound(int_element{ 5, 0.8f }) == cs.end());
    REQUIRE(cs.upper_bound(int_element{ 6, 0.0f }) == cs.end());

    return true;
}


constexpr bool int_set_find()
{
    // find on keys
    int_set s = { {3, 1.0f}, {5, 0.8f} };
    REQUIRE(s.find(0) == s.end());
    REQUIRE((*s.find(3) == int_element{ 3, 1.0f }));
    REQUIRE(s.find(4) == s.end());
    REQUIRE((*s.find(5) == int_element{ 5, 0.8f }));
    REQUIRE(s.find(6) == s.end());

    int_set const cs = { {3, 1.0f}, {5, 0.8f} };
    REQUIRE(cs.find(0) == cs.end());
    REQUIRE((*cs.find(3) == int_element{ 3, 1.0f }));
    REQUIRE(cs.find(4) == cs.end());
    REQUIRE((*cs.find(5) == int_element{ 5, 0.8f }));
    REQUIRE(cs.find(6) == cs.end());

    // find on elements
    REQUIRE(s.find(int_element{ 0, 0.0f }) == s.end());
    REQUIRE((*s.find(int_element{ 3, 1.0f }) == int_element{ 3, 1.0f }));
    REQUIRE(s.find(int_element{ 3, 0.0f }) == s.end());
    REQUIRE(s.find(int_element{ 4, 0.0f }) == s.end());
    REQUIRE((*s.find(int_element{ 5, 0.8f }) == int_element{ 5, 0.8f }));
    REQUIRE(s.find(int_element{ 6, 1.0f }) == s.end());

    REQUIRE(cs.find(int_element{ 0, 1.0f }) == cs.end());
    REQUIRE((*cs.find(int_element{ 3, 1.0f }) == int_element{ 3, 1.0f }));
    REQUIRE(cs.find(int_element{ 4, 1.0f }) == cs.end());
    REQUIRE((*cs.find(int_element{ 5, 0.8f }) == int_element{ 5, 0.8f }));
    REQUIRE(cs.find(int_element{ 5, 0.7f }) == cs.end());
    REQUIRE(cs.find(int_element{ 6, 0.0f }) == cs.end());

    return true;
}

constexpr bool int_set_contains()
{
    // find on keys
    int_set const cs = { {3, 1.0f}, {5, 0.8f} };
    REQUIRE(!cs.contains(0));
    REQUIRE(cs.contains(3));
    REQUIRE(!cs.contains(4));
    REQUIRE(cs.contains(5));
    REQUIRE(!cs.contains(6));

    // find on elements
    REQUIRE(!cs.contains(int_element{ 0, 1.0f }));
    REQUIRE(cs.contains(int_element{ 3, 1.0f }));
    REQUIRE(!cs.contains(int_element{ 3, 0.7f }));
    REQUIRE(!cs.contains(int_element{ 4, 1.0f }));
    REQUIRE(cs.contains(int_element{ 5, 0.8f }));
    REQUIRE(!cs.contains(int_element{ 5, 1.0f }));
    REQUIRE(!cs.contains(int_element{ 6, 0.0f }));

    return true;
}

constexpr bool int_set_count()
{
    // count on keys
    int_set const cs = { {3, 1.0f}, {5, 0.8f} };
    REQUIRE(cs.count(0) == 0u);
    REQUIRE(cs.count(3) == 1u);
    REQUIRE(cs.count(4) == 0u);
    REQUIRE(cs.count(5) == 1u);
    REQUIRE(cs.count(6) == 0u);

    // count on elements
    REQUIRE(cs.count(int_element{ 0, 1.0f }) == 0u);
    REQUIRE(cs.count(int_element{ 3, 1.0f }) == 1u);
    REQUIRE(cs.count(int_element{ 3, 0.7f }) == 0u);
    REQUIRE(cs.count(int_element{ 4, 1.0f }) == 0u);
    REQUIRE(cs.count(int_element{ 5, 0.8f }) == 1u);
    REQUIRE(cs.count(int_element{ 5, 1.0f }) == 0u);
    REQUIRE(cs.count(int_element{ 6, 0.0f }) == 0u);

    return true;
}

constexpr bool int_set_insert()
{
    // insertion of elements.
    int_set cs;
    cs.insert({ {3, 1.0f}, {5, 0.8f} });
    REQUIRE(cs.count(0) == 0u);
    REQUIRE(cs.count(3) == 1u);
    REQUIRE(cs.count(4) == 0u);
    REQUIRE(cs.count(5) == 1u);
    REQUIRE(cs.count(6) == 0u);

    cs.insert(int_element{ 4, 0.4f });
    REQUIRE(cs.contains(4));
    cs.insert(cs.cend(), int_element{ 0, 0.3f });
    REQUIRE(cs.contains(0));

    std::vector<int_element> const other = { {7, 1.0f}, {5, 0.0f}, {6, 0.6f} };
    cs.insert(other.begin(), other.end());
    REQUIRE(cs.contains(int_element{ 5, 0.8f }));
    REQUIRE(cs.contains(int_element{ 6, 0.6f }));
    REQUIRE(cs.contains(int_element{ 7, 1.0f }));

    auto pair1 = cs.insert(cs.begin(), int_element{ 4, 1.0f });
    REQUIRE(pair1.second == false);
    REQUIRE(pair1.first != cs.end());

    auto pair2 = cs.insert(cs.end(), int_element{ -1, 0.1f });
    REQUIRE(pair2.second == true);
    REQUIRE(pair2.first == cs.begin());

    return true;
}


constexpr bool TR0_int_set()
{
    int_set item = make_triangle<float>(4, 8, 12);
    REQUIRE(item.membership(2) == 0.0f);
    REQUIRE(item.membership(4) == 0.0f);
    REQUIRE(item.membership(6) == 0.5f);
    REQUIRE(item.membership(8) == 1.0f);
    REQUIRE(item.membership(10) == 0.5f);
    REQUIRE(item.membership(12) == 0.0f);
    REQUIRE(item.membership(14) == 0.0f);

    REQUIRE(!item.empty());
    REQUIRE(item.size() == 3u);
    REQUIRE(all_ranges_valid(item));
    REQUIRE(item.find(int_element{ 0, 0.3f }) == item.cend());
    REQUIRE(item.find(int_element{ 8, 1.0f }) != item.cend());
    REQUIRE(!item.contains(0));
    REQUIRE(item.contains(4));
    REQUIRE(item.count(0) == 0);
    REQUIRE(item.count(4) == 1);
    REQUIRE(item.count(int_element{ 0, 0.3f }) == 0);
    REQUIRE(item.count(int_element{ 12, 0.0f }) == 1);

    return true;
}


constexpr bool TR1_int_set()
{
    int_set item = make_trapezoid<float>(4, 8, 12, 16);
    REQUIRE(item.membership(2) == 0.0f);
    REQUIRE(item.membership(4) == 0.0f);
    REQUIRE(item.membership(6) == 0.5f);
    REQUIRE(item.membership(8) == 1.0f);
    REQUIRE(item.membership(10) == 1.0f);
    REQUIRE(item.membership(12) == 1.0f);
    REQUIRE(item.membership(14) == 0.5f);
    REQUIRE(item.membership(16) == 0.0f);
    REQUIRE(item.membership(18) == 0.0f);

    REQUIRE(!item.empty());
    REQUIRE(item.size() == 4u);
    REQUIRE(all_ranges_valid(item));
    REQUIRE(item.find(int_element{ 0, 0.3f }) == item.cend());
    REQUIRE(item.find(int_element{ 8, 1.0f }) != item.cend());
    REQUIRE((*item.find(int_element{ 8, 1.0f }) == int_element{ 8, 1.0f }));
    REQUIRE(!item.contains(0));
    REQUIRE(item.contains(4));
    REQUIRE(item.count(0) == 0);
    REQUIRE(item.count(4) == 1);
    REQUIRE(item.count(int_element{ 8, 1.0f }) == 1);
    REQUIRE(item.count(int_element{ std::numeric_limits<int>::max(), 0.3f }) == 0);
    REQUIRE(item.count(int_element{ std::numeric_limits<int>::max(), 0.0f }) == 0);

    return true;
}

constexpr bool SET_complement()
{
    // Default case.
    int_set const empty;
    int_set const empty_c = ~empty;
    REQUIRE(empty_c.size() == 2u);
    REQUIRE(empty_c.membership(std::numeric_limits<int>::lowest()) == 1.0f);
    REQUIRE(empty_c.membership(0) == 1.0f);
    REQUIRE(empty_c.membership(std::numeric_limits<int>::max()) == 1.0f);

    // Common case.
    int_set const tri = make_triangle<float>(4, 8, 12);
    int_set const tri_c = ~tri;
    REQUIRE(tri_c.membership(std::numeric_limits<int>::lowest()) == 1.0f);
    REQUIRE(tri_c.membership(4) == 1.0f);
    REQUIRE(tri_c.membership(6) == 0.5f);
    REQUIRE(tri_c.membership(8) == 0.0f);
    REQUIRE(tri_c.membership(10) == 0.5f);
    REQUIRE(tri_c.membership(12) == 1.0f);
    REQUIRE(tri_c.membership(std::numeric_limits<int>::max()) == 1.0f);

    // Extreme boundary case
    int_set const eb_tri = make_triangle<float>(std::numeric_limits<int>::lowest(), 0, std::numeric_limits<int>::max());
    int_set const eb_tri_c = ~eb_tri;
    REQUIRE(eb_tri_c.membership(std::numeric_limits<int>::lowest()) == 1.0f);
    REQUIRE(eb_tri_c.membership(0) == 0.0f);
    REQUIRE(eb_tri_c.membership(std::numeric_limits<int>::max()) == 1.0f);

    // Near extreme boundary case
    int_set const neb_tri = make_triangle<float>(std::numeric_limits<int>::lowest() + 1, 0, std::numeric_limits<int>::max() - 1);
    int_set const neb_tri_c = ~neb_tri;
    REQUIRE(neb_tri_c.membership(std::numeric_limits<int>::lowest()) == 1.0f);
    REQUIRE(neb_tri_c.membership(std::numeric_limits<int>::lowest() + 1) == 1.0f);
    REQUIRE(neb_tri_c.membership(0) == 0.0f);
    REQUIRE(neb_tri_c.membership(std::numeric_limits<int>::max() - 1) == 1.0f);
    REQUIRE(neb_tri_c.membership(std::numeric_limits<int>::max()) == 1.0f);

    return true;
}

constexpr bool SET_intersection()
{
    using int_element = basic_element<int, float>;
    using element = basic_element<float, float>;

    // Triangle No overlap case L-R,
    {
        int_set s = set_intersection<fuzzy::minimum>(make_triangle<float>(4, 8, 12), make_triangle<float>(16, 20, 24));
        REQUIRE(s.size() == 0u);
    }

    // Triangle No overlap case R-L,
    {
        int_set s = set_intersection<fuzzy::minimum>(make_triangle<float>(16, 20, 24), make_triangle<float>(4, 8, 12));
        REQUIRE(s.size() == 0u);
    }

    // Triangle Touching case R-L
    {
        int_set s = set_intersection<fuzzy::minimum>(make_triangle<float>(4, 8, 12), make_triangle<float>(12, 16, 20));
        REQUIRE(s.size() == 0u);
    }

    // Triangle Touching case L-R
    {
        int_set s = set_intersection<fuzzy::minimum>(make_triangle<float>(12, 16, 20), make_triangle<float>(4, 8, 12));
        REQUIRE(s.size() == 0u);
    }

    // Perfectly overlapped
    {
        int_set s = set_intersection<fuzzy::minimum>(make_triangle<float>(4, 8, 12), make_triangle<float>(4, 8, 12));
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 4, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 8, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 12, 0.0f }));
    }

    // Half overlap case (idiomatic) L-R
    {
        int_set s = set_intersection<fuzzy::minimum>(make_triangle<float>(4, 8, 12), make_triangle<float>(8, 12, 16));
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 8, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 10, 0.5f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 12, 0.0f }));
    }

    // Half overlap case (idiomatic) R-L
    {
        int_set s = set_intersection<fuzzy::minimum>(make_triangle<float>(8, 12, 16), make_triangle<float>(4, 8, 12));
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 8, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 10, 0.5f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 12, 0.0f }));
    }

    // Cap over cap case L-R
    {
        int_set s = set_intersection<fuzzy::minimum>(make_triangle<float>(4, 8, 12), make_triangle<float>(6, 8, 10));
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 6, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 8, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 10, 0.0f }));
    }

    // Cap over cap case R-L
    {
        int_set s = set_intersection<fuzzy::minimum>(make_triangle<float>(6, 8, 10), make_triangle<float>(4, 8, 12));
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 6, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 8, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 10, 0.0f }));
    }

    // Triangle overlaps segment-0 L-R
    {
        set s = set_intersection<fuzzy::minimum>(make_triangle<float>(4.0f, 6.0f, 8.0f), make_triangle<float>(4.0f, 8.0f, 12.0f));
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.666667f, 0.666667f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.0f }));
    }

    // Triangle overlaps segment-0 R-L
    {
        set s = set_intersection<fuzzy::minimum>(make_triangle<float>(4.0f, 8.0f, 12.0f), make_triangle<float>(4.0f, 6.0f, 8.0f));
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.666667f, 0.666667f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.0f }));
    }

    // Triangle overlaps segment-1 L-R
    {
        set s = set_intersection<fuzzy::minimum>(make_triangle<float>(8.0f, 10.0f, 12.0f), make_triangle<float>(4.0f, 8.0f, 12.0f));
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 9.333333f, 0.666667f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }

    // Triangle overlaps segment-1 R-L
    {
        set s = set_intersection<fuzzy::minimum>(make_triangle<float>(4.0f, 8.0f, 12.0f), make_triangle<float>(8.0f, 10.0f, 12.0f));
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 9.333333f, 0.666667f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }


    // Triangle intersects segment-0 L-R
    {
        set s = set_intersection<fuzzy::minimum>(make_triangle<float>(4.0f, 8.0f, 12.0f), make_triangle<float>(5.0f, 6.0f, 7.0f));
        REQUIRE(s.size() == 4u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 5.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 5.333333f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.4f, 0.6f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 7.0f, 0.0f }));
    }

    // Triangle intersects segment-0 R-L
    {
        set s = set_intersection<fuzzy::minimum>(make_triangle<float>(5.0f, 6.0f, 7.0f), make_triangle<float>(4.0f, 8.0f, 12.0f));
        REQUIRE(s.size() == 4u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 5.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 5.333333f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.4f, 0.6f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 7.0f, 0.0f }));
    }

    // Triangle intersects segment-1 L-R
    {
        set s = set_intersection<fuzzy::minimum>(make_triangle<float>(4.0f, 8.0f, 12.0f), make_triangle<float>(9.0f, 10.0f, 11.0f));
        REQUIRE(s.size() == 4u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 9.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 9.6f, 0.6f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 10.666667f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 11.0f, 0.0f }));
    }

    // Triangle intersects segment-1 R-L
    {
        set s = set_intersection<fuzzy::minimum>(make_triangle<float>(9.0f, 10.0f, 11.0f), make_triangle<float>(4.0f, 8.0f, 12.0f));
        REQUIRE(s.size() == 4u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 9.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 9.6f, 0.6f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 10.666667f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 11.0f, 0.0f }));
    }

    // Triangle intersections segments-0-1 L-R
    {
        set s = set_intersection<fuzzy::minimum>(make_triangle<float>(6.0f, 8.0f, 10.0f), set{ {4.0f, 0.0f}, {8.0f, 0.5f}, {12.0f, 0.0f} });
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 6.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.666667f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.5f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 9.333333f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 10.0f, 0.0f }));
    }

    // Triangle intersections segments-0-1 R-L
    {
        set s = set_intersection<fuzzy::minimum>(set{ {4.0f, 0.0f}, {8.0f, 0.5f}, {12.0f, 0.0f} }, make_triangle<float>(6.0f, 8.0f, 10.0f));
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 6.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.666667f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.5f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 9.333333f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 10.0f, 0.0f }));
    }

    // Triangle intersections segments-0-1 offset L-R
    {
        set s = set_intersection<fuzzy::minimum>(make_triangle<float>(6.0f, 7.0f, 10.0f), set{ {4.0f, 0.0f}, {8.0f, 0.5f}, {12.0f, 0.0f} });
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 6.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.285714f, 0.285714f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.5f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.8f, 0.4f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 10.0f, 0.0f }));
    }

    // Triangle intersections segments-0-1 offset R-L
    {
        set s = set_intersection<fuzzy::minimum>(set{ {4.0f, 0.0f}, {8.0f, 0.5f}, {12.0f, 0.0f} }, make_triangle<float>(6.0f, 7.0f, 10.0f));
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 6.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.285714f, 0.285714f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.5f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.8f, 0.4f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 10.0f, 0.0f }));
    }

    // Single segment intersection overlapped L-R
    {
        set s = set_intersection<fuzzy::minimum>(set{ {4.0f, 0.0f}, {8.0f, 1.0f} }, set{ {4.0f, 1.0f}, {8.0f, 0.0f} });
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.0f, 0.5f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.0f }));
        ++itr;
    }

    // Single segment intersection overlapped R-L
    {
        set s = set_intersection<fuzzy::minimum>(set{ {4.0f, 1.0f}, {8.0f, 0.0f} }, set{ {4.0f, 0.0f}, {8.0f, 1.0f} });
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.0f, 0.5f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.0f }));
        ++itr;
    }


    // Single segment intersection offset L-R
    {
        set s = set_intersection<fuzzy::minimum>(set{ {3.0f, 0.0f}, {7.0f, 1.0f} }, set{ {4.0f, 1.0f}, {8.0f, 0.0f} });
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 3.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 5.5f, 0.625f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.0f }));
        ++itr;
    }

    // Single segment intersection offset R-L
    {
        set s = set_intersection<fuzzy::minimum>(set{ {4.0f, 1.0f}, {8.0f, 0.0f} }, set{ {3.0f, 0.0f}, {7.0f, 1.0f} });
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 3.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 5.5f, 0.625f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.0f }));
        ++itr;
    }

    // Single segment intersection disjoint L-R
    {
        set s = set_intersection<fuzzy::minimum>(set{ {-1.0f, 1.0f}, {3.0f, 0.0f} }, set{ {4.0f, 0.0f}, {8.0f, 1.0f} });
        REQUIRE(s.size() == 0u);
    }

    // Single segment intersection disjoint R-L
    {
        set s = set_intersection<fuzzy::minimum>(set{ {4.0f, 0.0f}, {8.0f, 1.0f} }, set{ {-1.0f, 1.0f}, {3.0f, 0.0f} });
        REQUIRE(s.size() == 0u);
    }

    // Signle segment touching L-R
    {
        set s = set_intersection<fuzzy::minimum>(set{ {0.0f, 1.0f}, {4.0f, 0.0f} }, set{ {4.0f, 0.0f}, {8.0f, 1.0f} });
        REQUIRE(s.size() == 0u);
    }

    // Signle segment touching R-L
    {
        set s = set_intersection<fuzzy::minimum>(set{ {4.0f, 0.0f}, {8.0f, 1.0f} }, set{ {0.0f, 1.0f}, {4.0f, 0.0f} });
        REQUIRE(s.size() == 0u);
    }

    return true;
}

constexpr bool SET_union()
{
    using int_element = basic_element<int, float>;
    using element = basic_element<float, float>;

    // Triangle No overlap case L-R,
    {
        int_set s = set_union<fuzzy::maximum>(make_triangle<float>(4, 8, 12), make_triangle<float>(16, 20, 24));
        REQUIRE(s.size() == 6u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 4, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 8, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 12, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 16, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 20, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 24, 0.0f }));
    }

    // Triangle No overlap case R-L,
    {
        int_set s = set_union<fuzzy::maximum>(make_triangle<float>(16, 20, 24), make_triangle<float>(4, 8, 12));
        REQUIRE(s.size() == 6u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 4, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 8, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 12, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 16, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 20, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 24, 0.0f }));
    }

    // Triangle Touching case R-L
    {
        int_set s = set_union<fuzzy::maximum>(make_triangle<float>(4, 8, 12), make_triangle<float>(12, 16, 20));
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 4, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 8, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 12, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 16, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 20, 0.0f }));
    }

    // Triangle Touching case L-R
    {
        int_set s = set_union<fuzzy::maximum>(make_triangle<float>(12, 16, 20), make_triangle<float>(4, 8, 12));
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 4, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 8, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 12, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 16, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 20, 0.0f }));
    }

    // Perfectly overlapped
    {
        int_set s = set_union<fuzzy::maximum>(make_triangle<float>(4, 8, 12), make_triangle<float>(4, 8, 12));
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 4, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 8, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 12, 0.0f }));
    }

    // Half overlap case (idiomatic) L-R
    {
        int_set s = set_union<fuzzy::maximum>(make_triangle<float>(4, 8, 12), make_triangle<float>(8, 12, 16));
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 4, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 8, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 10, 0.5f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 12, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 16, 0.0f }));
    }

    // Half overlap case (idiomatic) R-L
    {
        int_set s = set_union<fuzzy::maximum>(make_triangle<float>(8, 12, 16), make_triangle<float>(4, 8, 12));
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 4, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 8, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 10, 0.5f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 12, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 16, 0.0f }));
    }

    // Cap over cap case L-R
    {
        int_set s = set_union<fuzzy::maximum>(make_triangle<float>(4, 8, 12), make_triangle<float>(6, 8, 10));
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 4, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 8, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 12, 0.0f }));
    }

    // Cap over cap case R-L
    {
        int_set s = set_union<fuzzy::maximum>(make_triangle<float>(6, 8, 10), make_triangle<float>(4, 8, 12));
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, int_element{ 4, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 8, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, int_element{ 12, 0.0f }));
    }

    // Triangle overlaps segment-0 L-R
    {
        set s = set_union<fuzzy::maximum>(make_triangle<float>(4.0f, 6.0f, 8.0f), make_triangle<float>(4.0f, 8.0f, 12.0f));
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.666667f, 0.666667f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }

    // Triangle overlaps segment-0 R-L
    {
        set s = set_union<fuzzy::maximum>(make_triangle<float>(4.0f, 8.0f, 12.0f), make_triangle<float>(4.0f, 6.0f, 8.0f));
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.666667f, 0.666667f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }

    // Triangle overlaps segment-1 L-R
    {
        set s = set_union<fuzzy::maximum>(make_triangle<float>(8.0f, 10.0f, 12.0f), make_triangle<float>(4.0f, 8.0f, 12.0f));
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 9.333333f, 0.666667f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 10.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }

    // Triangle overlaps segment-1 R-L
    {
        set s = set_union<fuzzy::maximum>(make_triangle<float>(4.0f, 8.0f, 12.0f), make_triangle<float>(8.0f, 10.0f, 12.0f));
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 9.333333f, 0.666667f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 10.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }


    // Triangle intersects segment-0 L-R
    {
        set s = set_union<fuzzy::maximum>(make_triangle<float>(4.0f, 8.0f, 12.0f), make_triangle<float>(5.0f, 6.0f, 7.0f));
        REQUIRE(s.size() == 6u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 5.333333f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.4f, 0.6f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }

    // Triangle intersects segment-0 R-L
    {
        set s = set_union<fuzzy::maximum>(make_triangle<float>(5.0f, 6.0f, 7.0f), make_triangle<float>(4.0f, 8.0f, 12.0f));
        REQUIRE(s.size() == 6u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 5.333333f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.4f, 0.6f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }

    // Triangle intersects segment-1 L-R
    {
        set s = set_union<fuzzy::maximum>(make_triangle<float>(4.0f, 8.0f, 12.0f), make_triangle<float>(9.0f, 10.0f, 11.0f));
        REQUIRE(s.size() == 6u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 9.6f, 0.6f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 10.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 10.666667f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }

    // Triangle intersects segment-1 R-L
    {
        set s = set_union<fuzzy::maximum>(make_triangle<float>(9.0f, 10.0f, 11.0f), make_triangle<float>(4.0f, 8.0f, 12.0f));
        REQUIRE(s.size() == 6u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 9.6f, 0.6f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 10.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 10.666667f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }

    // Triangle intersections segments-0-1 L-R
    {
        set s = set_union<fuzzy::maximum>(make_triangle<float>(6.0f, 8.0f, 10.0f), set{ {4.0f, 0.0f}, {8.0f, 0.5f}, {12.0f, 0.0f} });
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.666667f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 9.333333f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }

    // Triangle intersections segments-0-1 R-L
    {
        set s = set_union<fuzzy::maximum>(set{ {4.0f, 0.0f}, {8.0f, 0.5f}, {12.0f, 0.0f} }, make_triangle<float>(6.0f, 8.0f, 10.0f));
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.666667f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 9.333333f, 0.333333f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }

    // Triangle intersections segments-0-1 offset L-R
    {
        set s = set_union<fuzzy::maximum>(make_triangle<float>(6.0f, 7.0f, 10.0f), set{ {4.0f, 0.0f}, {8.0f, 0.5f}, {12.0f, 0.0f} });
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.285714f, 0.285714f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 7.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.8f, 0.4f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }

    // Triangle intersections segments-0-1 offset R-L
    {
        set s = set_union<fuzzy::maximum>(set{ {4.0f, 0.0f}, {8.0f, 0.5f}, {12.0f, 0.0f} }, make_triangle<float>(6.0f, 7.0f, 10.0f));
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.285714f, 0.285714f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 7.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.8f, 0.4f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 12.0f, 0.0f }));
    }

    // Single segment intersection overlapped L-R
    {
        set s = set_union<fuzzy::maximum>(set{ {4.0f, 0.0f}, {8.0f, 1.0f} }, set{ {4.0f, 1.0f}, {8.0f, 0.0f} });
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.0f, 0.5f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
        ++itr;
    }

    // Single segment intersection overlapped R-L
    {
        set s = set_union<fuzzy::maximum>(set{ {4.0f, 1.0f}, {8.0f, 0.0f} }, set{ {4.0f, 0.0f}, {8.0f, 1.0f} });
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 4.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 6.0f, 0.5f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
        ++itr;
    }


    // Single segment intersection offset L-R
    {
        set s = set_union<fuzzy::maximum>(set{ {3.0f, 0.0f}, {7.0f, 1.0f} }, set{ {4.0f, 1.0f}, {8.0f, 0.0f} });
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 3.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 4.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 5.5f, 0.625f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 7.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.0f }));
        ++itr;
    }

    // Single segment intersection offset R-L
    {
        set s = set_union<fuzzy::maximum>(set{ {4.0f, 1.0f}, {8.0f, 0.0f} }, set{ {3.0f, 0.0f}, {7.0f, 1.0f} });
        REQUIRE(s.size() == 5u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 3.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 4.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 5.5f, 0.625f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 7.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 0.0f }));
        ++itr;

    }

    // Single segment intersection disjoint L-R
    {
        set s = set_union<fuzzy::maximum>(set{ {-1.0f, 1.0f}, {3.0f, 0.0f} }, set{ {4.0f, 0.0f}, {8.0f, 1.0f} });
        REQUIRE(s.size() == 4u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ -1.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 3.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
    }

    // Single segment intersection disjoint R-L
    {
        set s = set_union<fuzzy::maximum>(set{ {4.0f, 0.0f}, {8.0f, 1.0f} }, set{ {-1.0f, 1.0f}, {3.0f, 0.0f} });
        REQUIRE(s.size() == 4u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ -1.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 3.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
    }

    // Signle segment touching L-R
    {
        set s = set_union<fuzzy::maximum>(set{ {0.0f, 1.0f}, {4.0f, 0.0f} }, set{ {4.0f, 0.0f}, {8.0f, 1.0f} });
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 0.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
    }

    // Signle segment touching R-L
    {
        set s = set_union<fuzzy::maximum>(set{ {4.0f, 0.0f}, {8.0f, 1.0f} }, set{ {0.0f, 1.0f}, {4.0f, 0.0f} });
        REQUIRE(s.size() == 3u);

        auto itr = s.cbegin();
        REQUIRE(equivelant(*itr, element{ 0.0f, 1.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 4.0f, 0.0f }));
        ++itr;
        REQUIRE(equivelant(*itr, element{ 8.0f, 1.0f }));
    }

    return true;
}

consteval void evaluate_static_tests()
{
    static_assert(membership_bounds_check());
    static_assert(t_norm_tests());
    static_assert(t_conorm_tests());
    static_assert(basic_element_tests());
    static_assert(empty_int_set());
    static_assert(one_int_element_int_set());
    static_assert(two_int_element_int_set());
    static_assert(int_set_equivalence());
    static_assert(int_set_copy_construct());
    static_assert(int_set_move_construct());
    static_assert(int_set_assignment());
    static_assert(int_set_lowerbound());
    static_assert(int_set_upperbound());
    static_assert(int_set_find());
    static_assert(int_set_find());
    static_assert(int_set_contains());
    static_assert(int_set_count());
    static_assert(int_set_insert());
    static_assert(TR0_int_set());
    static_assert(TR1_int_set());
    static_assert(SET_complement());
    static_assert(SET_intersection());
    static_assert(SET_union());
};





