//  Copyright (c) 2025, Ben McCart
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.

#ifndef FUZZY_OPERATORS_HPP
#define FUZZY_OPERATORS_HPP

#include <fuzzy/algorithm.hpp>
#include <fuzzy/norm_conorm.hpp>
#include <fuzzy/result_aggregator.hpp>
#include <fuzzy/scaled_mapping.hpp>

namespace fuzzy
{

	/**
	* Fuzzy term 'somewhat' relaxes requirement for the fuzzy set.
	* @param aset The set to relax.
	* @return The relaxed set.
	*/
	template <class V, class M, class Operation = maximum<M>, template <typename T, typename Alloc = std::allocator<T>> class Container>
	requires numeric<V>&& std::floating_point<M>
	[[nodiscard]] constexpr basic_set<V, M, Container> somewhat(basic_set<V, M, Container> const& aset, std::size_t steps = linguistic_term_default_steps)
	{
		constexpr auto somewhat_func = [](M m) { return std::sqrt(m); };
		return detail::linguistic_term_impl(aset, somewhat_func, steps);
	}

	/**
	* Fuzzy term 'verry' tightens requirement for the fuzzy set.
	* @param aset The set to tighten.
	* @return The tightened set.
	*/
	template <class V, class M, class Operation = maximum<M>, template <typename T, typename Alloc = std::allocator<T>> class Container>
	requires numeric<V>&& std::floating_point<M>
	[[nodiscard]] constexpr basic_set<V, M, Container> very(basic_set<V, M, Container> const& aset, std::size_t steps = linguistic_term_default_steps)
	{
		constexpr auto very_func = [](M m) { return m * m; };
		return detail::linguistic_term_impl(aset, very_func, steps);
	}

	/**
	* Complement of fuzzy set.
	* @param aset The set to complement.
	* @return The complement of the set.
	*/
	template <class V, class M, class Operation = maximum<M>, template <typename T, typename Alloc = std::allocator<T>> class Container>
	requires numeric<V>&& std::floating_point<M>
	[[nodiscard]] constexpr basic_set<V, M, Container> operator~(basic_set<V, M, Container> const& aset)
	{
		return set_complement<V, M, Operation, Container>(aset);
	}

	/**
	 * @brief Applies the fuzzy value to the fuzzy variable.  i.e. make_antecedent(tempurature, hot)
	 * @tparam M The fuzzy element membership type.
	 * @tparam Tnorm The T-norm to use in the application.
	 * @tparam Container The container type to use for the fuzzy basic_set.
	 * @tparam V The fuzzy element value type.
	 * @param value The fuzzy value to apply.
	 * @param variable The fuzzy variable to apply the value against.
	 * @return A scaled application of a fuzzy value to a fuzzy variable.
	*/
	template <template<typename> class Tnorm = minimum, class V, class M, template <typename T, typename Alloc = std::allocator<T>> class Container, class Allocator>
	requires numeric<V> && std::floating_point<M>&& tnorm_type<Tnorm<M>>
	constexpr scaled_antecedent<V, M, Container, Allocator> make_antecedent(basic_set<V, M, Container, Allocator> const& value, basic_set<V, M, Container, Allocator> const& variable) // FIXME: rename 'is' to 'make_antecedent' and create alias 'is' in each tnorm oeprator namespace.
	{
		using key_type = typename float_value_t<V>::value;
		if (variable.empty())
			return scaled_antecedent<V, M, Container>{ };

		// Get the set intersection.
		key_type const d0 = static_cast<key_type>(variable.front().value());
		key_type const d1 = static_cast<key_type>(variable.back().value());
		key_type const domain_ratio = static_cast<key_type>(1) / (d1 - d0);
		basic_set<V, M, Container, Allocator> const set = set_intersection<Tnorm, V, M, Container, Allocator>(value, variable);
		using key_alloc_type = typename std::allocator_traits<Allocator>::template rebind_alloc<basic_element<key_type, M>>;

		// Scale the set intersection to the range of the variable as [0,1].
		basic_set<key_type, M, Container, key_alloc_type> scaled_set{ key_alloc_type{variable.get_allocator()} };
		scaled_set.reserve(set.size());
		for (basic_element<V, M> const& e : set)
		{
			key_type const offset = static_cast<key_type>(e.value()) - d0;
			key_type const scaled_value = offset * domain_ratio;
			scaled_set.insert(basic_element<key_type, M>{ scaled_value, e.membership() });
		}

		// Essentially apply a scaling inference by widening the range of the scaled set to [0,1].
		if (scaled_set.size() < 2)
		{
			return scaled_antecedent<V, M, Container>{ };
		}
		scaled_set.front().value(static_cast<V>(0));
		scaled_set.back().value(static_cast<V>(1));

		// Simplify the set.
		fuzzy::detail::simplify_impl::apply(scaled_set); // FIXME: benchmark this.

		return scaled_antecedent<V, M, Container, Allocator>{ std::move(scaled_set) };
	}

	///**
	//* Intersects two fuzzy sets.
	//* @param aset The lhs set to intersect.
	//* @return The intersection of the sets.
	//*/
	//template <class V, class M, class Operation = maximum<M>, template <typename T, typename Alloc> class Container>
	//requires numeric<V>&& std::floating_point<M>
	//[[nodiscard]] constexpr basic_set<V, M, Container> operator&(basic_set<V, M, Container> const& lhs, basic_set<V, M, Container> const& rhs)
	//{
	//	return set_intersection<V, M, Operation, Container>(lhs, rhs);
	//}

	///**
	//* Unions two fuzzy sets.
	//* @param aset The lhs set to intersect.
	//* @return The unions of the sets.
	//*/
	//template <class V, class M, class Operation = maximum<M>, template <typename T, typename Alloc> class Container>
	//requires numeric<V>&& std::floating_point<M>
	//[[nodiscard]] constexpr basic_set<V, M, Container> operator|(basic_set<V, M, Container> const& lhs, basic_set<V, M, Container> const& rhs)
	//{
	//	return set_union<V, M, Operation, Container>(lhs, rhs);
	//}

	 /**
	 * @brief A version of std::set_intersection compatible with fuzzy set theory for antecedent sets.
	 * @tparam V The element value type.
	 * @tparam M The element membership type.
	 * @tparam Allocator The allocator type.
	 * @param lhs The left-hand set for the intersection.
	 * @param rhs The right-hand set for the intersection.
	 * @return An antecedant which is the intersection of the two operands.
	*/
	template <template<typename> class Operation, class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
	requires numeric<V>&& std::floating_point<M>&& tnorm_type<Operation<M>>
	[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> antecedent_intersection( scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
	{
		return scaled_antecedent<V, M, Container, Allocator>{  set_intersection<Operation>(lhs.set(), rhs.set()) };
	}

	/**
	 * @brief A version of std::set_union compatible with fuzzy set theory for antecedent sets.
	 * @tparam V The element value type.
	 * @tparam M The element membership type.
	 * @tparam Allocator The allocator type.
	 * @param lhs The left-hand set for the union.
	 * @param rhs The right-hand set for the union.
	 * @return A set which is the union of the two operands.
	*/
	template <template <typename> class Operation, class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
	requires numeric<V>&& std::floating_point<M>&& tconorm_type<Operation<M>>
	[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> antecedent_union(scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
	{
		return scaled_antecedent<V, M, Container, Allocator>{ set_union<Operation>(lhs.set(), rhs.set()) };
	}

	namespace functions
	{
		namespace algabraic_product
		{
			template <class V, class M, template <typename T, typename Alloc = std::allocator<T>> class Container, class Allocator>
			constexpr scaled_antecedent<V, M, Container, Allocator> is(basic_set<V, M, Container, Allocator> const& value, basic_set<V, M, Container, Allocator> const& variable)
			{
				return fuzzy::make_antecedent<fuzzy::algabraic_product>(value, variable);
			}
		}
		namespace bounded_difference
		{
			template <class V, class M, template <typename T, typename Alloc = std::allocator<T>> class Container, class Allocator>
			constexpr scaled_antecedent<V, M, Container, Allocator> is(basic_set<V, M, Container, Allocator> const& value, basic_set<V, M, Container, Allocator> const& variable)
			{
				return fuzzy::make_antecedent<fuzzy::bounded_difference>(value, variable);
			}
		}
		namespace drastic_product
		{
			template <class V, class M, template <typename T, typename Alloc = std::allocator<T>> class Container, class Allocator>
			constexpr scaled_antecedent<V, M, Container, Allocator> is(basic_set<V, M, Container, Allocator> const& value, basic_set<V, M, Container, Allocator> const& variable)
			{
				return fuzzy::make_antecedent<fuzzy::drastic_product>(value, variable);
			}
		}
		namespace einstein_product
		{
			template <class V, class M, template <typename T, typename Alloc = std::allocator<T>> class Container, class Allocator>
			constexpr scaled_antecedent<V, M, Container, Allocator> is(basic_set<V, M, Container, Allocator> const& value, basic_set<V, M, Container, Allocator> const& variable)
			{
				return fuzzy::make_antecedent<fuzzy::einstein_product>(value, variable);
			}
		}
		namespace hamacher_product
		{
			template <class V, class M, template <typename T, typename Alloc = std::allocator<T>> class Container, class Allocator>
			constexpr scaled_antecedent<V, M, Container, Allocator> is(basic_set<V, M, Container, Allocator> const& value, basic_set<V, M, Container, Allocator> const& variable)
			{
				return fuzzy::make_antecedent<fuzzy::hamacher_product>(value, variable);
			}
		}
		namespace minimum
		{
			template <class V, class M, template <typename T, typename Alloc = std::allocator<T>> class Container, class Allocator>
			constexpr scaled_antecedent<V, M, Container, Allocator> is(basic_set<V, M, Container, Allocator> const& value, basic_set<V, M, Container, Allocator> const& variable)
			{
				return fuzzy::make_antecedent<fuzzy::minimum>(value, variable);
			}
		}
		
	}

	namespace operators { namespace tnorm
	{
		namespace algabraic_product
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> operator&(scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return antecedent_intersection<fuzzy::algabraic_product>(lhs, rhs);
			}
		}
		namespace bounded_difference
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> operator&(scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return antecedent_intersection<fuzzy::bounded_difference>(lhs, rhs);
			}
		}
		namespace drastic_product
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> operator&(scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return antecedent_intersection<fuzzy::drastic_product>(lhs, rhs);
			}
		}
		namespace einstein_product
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> operator&(scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return antecedent_intersection<fuzzy::einstein_product>(lhs, rhs);
			}
		}
		namespace hamacher_product
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> operator&(scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return antecedent_intersection<fuzzy::hamacher_product>(lhs, rhs);
			}
		}
		namespace minimum
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> operator&(scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return antecedent_intersection<fuzzy::minimum>(lhs, rhs);
			}
		}
	}}

	namespace operators { namespace tconorm
	{
		namespace algabraic_sum
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> operator|(scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return antecedent_union<fuzzy::algabraic_sum>(lhs, rhs);
			}
		}
		namespace bounded_sum
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> operator|(scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return antecedent_union<fuzzy::bounded_sum>(lhs, rhs);
			}
		}
		namespace drastic_sum
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> operator|(scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return antecedent_union<fuzzy::drastic_sum>(lhs, rhs);
			}
		}
		namespace einstein_sum
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> operator|(scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return antecedent_union<fuzzy::einstein_sum>(lhs, rhs);
			}
		}
		namespace hamacher_sum
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> operator|(scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return antecedent_union<fuzzy::hamacher_sum>(lhs, rhs);
			}
		}
		namespace maximum
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr scaled_antecedent<V, M, Container, Allocator> operator|(scaled_antecedent<V, M, Container, Allocator> const& lhs, scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return antecedent_union<fuzzy::maximum>(lhs, rhs);
			}
		}

	}}

	namespace operators
	{
		namespace mapping
		{
			namespace algabraic_product
			{
				template <class V, class M, template <typename> class AggregatorFunc, template <typename T, typename Alloc = std::allocator<T>> class Container = std::vector, class Allocator = std::allocator<fuzzy::basic_element<V, M>>>
				constexpr void operator>>(scaled_antecedent<V, M, Container, Allocator> const& antecedent, consequent<V, M, AggregatorFunc, Container, Allocator> const& consequent) //??
				{
					scaled_mapping<fuzzy::algabraic_product>(antecedent, consequent);
				}
			}
			namespace bounded_difference
			{
				template <class V, class M, template <typename> class AggregatorFunc, template <typename T, typename Alloc = std::allocator<T>> class Container = std::vector, class Allocator = std::allocator<fuzzy::basic_element<V, M>>>
				constexpr void operator>>(scaled_antecedent<V, M, Container, Allocator> const& antecedent, consequent<V, M, AggregatorFunc, Container, Allocator> const& consequent) //??
				{
					scaled_mapping<fuzzy::bounded_difference>(antecedent, consequent);
				}
			}
			namespace drastic_product
			{
				template <class V, class M, template <typename> class AggregatorFunc, template <typename T, typename Alloc = std::allocator<T>> class Container = std::vector, class Allocator = std::allocator<fuzzy::basic_element<V, M>>>
				constexpr void operator>>(scaled_antecedent<V, M, Container, Allocator> const& antecedent, consequent<V, M, AggregatorFunc, Container, Allocator> const& consequent) //??
				{
					scaled_mapping<fuzzy::drastic_product>(antecedent, consequent);
				}
			}
			namespace einstein_product
			{
				template <class V, class M, template <typename> class AggregatorFunc, template <typename T, typename Alloc = std::allocator<T>> class Container = std::vector, class Allocator = std::allocator<fuzzy::basic_element<V, M>>>
				constexpr void operator>>(scaled_antecedent<V, M, Container, Allocator> const& antecedent, consequent<V, M, AggregatorFunc, Container, Allocator> const& consequent) //??
				{
					scaled_mapping<fuzzy::einstein_product>(antecedent, consequent);
				}
			}
			namespace hamacher_product
			{
				template <class V, class M, template <typename> class AggregatorFunc, template <typename T, typename Alloc = std::allocator<T>> class Container = std::vector, class Allocator = std::allocator<fuzzy::basic_element<V, M>>>
				constexpr void operator>>(scaled_antecedent<V, M, Container, Allocator> const& antecedent, consequent<V, M, AggregatorFunc, Container, Allocator> const& consequent) //??
				{
					scaled_mapping<fuzzy::hamacher_product>(antecedent, consequent);
				}
			}
			namespace minimum
			{
				template <class V, class M, template <typename> class AggregatorFunc, template <typename T, typename Alloc = std::allocator<T>> class Container = std::vector, class Allocator = std::allocator<fuzzy::basic_element<V, M>>>
				constexpr void operator>>(scaled_antecedent<V, M, Container, Allocator> const& antecedent, consequent<V, M, AggregatorFunc, Container, Allocator> const& consequent) //??
				{
					scaled_mapping<fuzzy::minimum>(antecedent, consequent);
				}
			}
		}
	}

	namespace operators { namespace algabraic
	{
		using namespace fuzzy::operators::tnorm::algabraic_product;
		using namespace fuzzy::operators::tconorm::algabraic_sum;
		using namespace fuzzy::operators::mapping::algabraic_product;
	}}

	namespace operators { namespace bounded
	{
		using namespace fuzzy::operators::tnorm::bounded_difference;
		using namespace fuzzy::operators::tconorm::bounded_sum;
		using namespace fuzzy::operators::mapping::bounded_difference;
	}}

	namespace operators { namespace drastic
	{
		using namespace fuzzy::operators::tnorm::drastic_product;
		using namespace fuzzy::operators::tconorm::drastic_sum;
		using namespace fuzzy::operators::mapping::drastic_product;
	}}

	namespace operators { namespace einstein
	{
		using namespace fuzzy::operators::tnorm::einstein_product;
		using namespace fuzzy::operators::tconorm::einstein_sum;
		using namespace fuzzy::operators::mapping::einstein_product;
	}}

	namespace operators { namespace hamacher
	{
		using namespace fuzzy::operators::tnorm::hamacher_product;
		using namespace fuzzy::operators::tconorm::hamacher_sum;
		using namespace fuzzy::operators::mapping::hamacher_product;
	}}

	namespace operators { namespace minmax
	{
		using namespace fuzzy::operators::tnorm::minimum;
		using namespace fuzzy::operators::tconorm::maximum;
		using namespace fuzzy::operators::mapping::minimum;
	}}

	namespace models { namespace mamdani
	{
		using namespace fuzzy::operators::tnorm::minimum;
		using namespace fuzzy::operators::tconorm::maximum;
		using namespace fuzzy::operators::mapping::minimum;
		using aggregator = maximum_aggregator;
		using int_aggregator = int_maximum_aggregator;
	}}

	namespace models { namespace tsk
	{
		using namespace fuzzy::operators::tnorm::minimum;
		using namespace fuzzy::operators::tconorm::maximum;
		using namespace fuzzy::operators::mapping::algabraic_product;
		using aggregator = additive_aggregator;
		using int_aggregator = int_additive_aggregator;
	}}
}


#endif // FUZZY_OPERATORS_HPP