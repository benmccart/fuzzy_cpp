//  Copyright (c) 2025, Ben McCart
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.

#ifndef FUZZY_OPERATORS_HPP
#define FUZZY_OPERATORS_HPP

#include <fuzzy/algorithm.hpp>
#include <fuzzy/norm_conorm.hpp>

namespace fuzzy
{

	/**
	* Fuzzy term 'somewhat' relaxes requirement for the fuzzy set.
	* @param aset The set to relax.
	* @return The relaxed set.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc = std::allocator<T>> class Container>
	requires fuzzy::numeric<V>&& std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> somewhat(fuzzy::basic_set<V, M, Container> const& aset, std::size_t steps = linguistic_term_default_steps)
	{
		constexpr auto somewhat_func = [](M m) { return std::sqrt(m); };
		return detail::linguistic_term_impl(aset, somewhat_func, steps);
	}

	/**
	* Fuzzy term 'verry' tightens requirement for the fuzzy set.
	* @param aset The set to tighten.
	* @return The tightened set.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc = std::allocator<T>> class Container>
	requires fuzzy::numeric<V>&& std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> very(fuzzy::basic_set<V, M, Container> const& aset, std::size_t steps = linguistic_term_default_steps)
	{
		constexpr auto very_func = [](M m) { return m * m; };
		return detail::linguistic_term_impl(aset, very_func, steps);
	}

	/**
	* Complement of fuzzy set.
	* @param aset The set to complement.
	* @return The complement of the set.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc = std::allocator<T>> class Container>
	requires fuzzy::numeric<V>&& std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> operator~(fuzzy::basic_set<V, M, Container> const& aset)
	{
		return set_complement<V, M, Operation, Container>(aset);
	}

	/**
	 * @brief Applies the fuzzy value to the fuzzy variable.  i.e. is(tempurature, hot)
	 * @tparam M The fuzzy element membership type.
	 * @tparam Tnorm The T-norm to use in the application.
	 * @tparam Container The container type to use for the fuzzy basic_set.
	 * @tparam V The fuzzy element value type.
	 * @param value The fuzzy value to apply.
	 * @param variable The fuzzy variable to apply the value against.
	 * @return A scaled application of a fuzzy value to a fuzzy variable.
	*/
	template <template<typename> class Tnorm = fuzzy::minimum, class V, class M, template <typename T, typename Alloc = std::allocator<T>> class Container, class Allocator>
	requires fuzzy::numeric<V>&& std::floating_point<M>&& fuzzy::tnorm_type<Tnorm<M>>
	constexpr scaled_antecedent<V, M, Container, Allocator> is(fuzzy::basic_set<V, M, Container, Allocator> const& value, fuzzy::basic_set<V, M, Container, Allocator> const& variable)
	{
		using key_type = typename fuzzy::float_value_t<V>::value;
		if (variable.empty())
			return scaled_antecedent<V, M, Container>{ };

		key_type const d0 = static_cast<key_type>(variable.front().value());
		key_type const d1 = static_cast<key_type>(variable.back().value());
		key_type const domain_ratio = static_cast<key_type>(1) / (d1 - d0);
		fuzzy::basic_set<V, M, Container, Allocator> const set = fuzzy::set_intersection<Tnorm, V, M, Container, Allocator>(value, variable);
		using key_alloc_type = typename std::allocator_traits<Allocator>::template rebind_alloc<fuzzy::basic_element<key_type, M>>;

		fuzzy::basic_set<key_type, M, Container, key_alloc_type> scaled_set{ key_alloc_type{variable.get_allocator()} };
		scaled_set.reserve(set.size());
		for (fuzzy::basic_element<V, M> const& e : set)
		{
			key_type const offset = static_cast<key_type>(e.value()) - d0;
			key_type const scaled_value = offset * domain_ratio;
			scaled_set.insert(fuzzy::basic_element<key_type, M>{ scaled_value, e.membership() });
		}

		return scaled_antecedent<V, M, Container, Allocator>{ std::move(scaled_set) };
	}

	///**
	//* Intersects two fuzzy sets.
	//* @param aset The lhs set to intersect.
	//* @return The intersection of the sets.
	//*/
	//template <class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc> class Container>
	//requires fuzzy::numeric<V>&& std::floating_point<M>
	//[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> operator&(fuzzy::basic_set<V, M, Container> const& lhs, fuzzy::basic_set<V, M, Container> const& rhs)
	//{
	//	return set_intersection<V, M, Operation, Container>(lhs, rhs);
	//}

	///**
	//* Unions two fuzzy sets.
	//* @param aset The lhs set to intersect.
	//* @return The unions of the sets.
	//*/
	//template <class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc> class Container>
	//requires fuzzy::numeric<V>&& std::floating_point<M>
	//[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> operator|(fuzzy::basic_set<V, M, Container> const& lhs, fuzzy::basic_set<V, M, Container> const& rhs)
	//{
	//	return set_union<V, M, Operation, Container>(lhs, rhs);
	//}

	 /**
	 * @brief A version of std::set_intersection compatible with fuzzy set theory for antecedent sets.
	 * @tparam V The element value type.
	 * @tparam M The element membership type.
	 * @tparam Allocator The allocator type.
	 * @param lhs The left-hand set for the intersection.
	 * @param rhs The right-hand set for the intersection.
	 * @return An antecedant which is the intersection of the two operands.
	*/
	template <template<typename> class Operation, class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
	requires fuzzy::numeric<V>&& std::floating_point<M>&& tnorm_type<Operation<M>>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> antecedent_intersection(fuzzy::scaled_antecedent<V, M, Container, Allocator> const& lhs, fuzzy::scaled_antecedent<V, M, Container, Allocator> const& rhs)
	{
		return fuzzy::set_intersection<Operation>(lhs.set(), rhs.set());
	}

	/**
	 * @brief A version of std::set_union compatible with fuzzy set theory for antecedent sets.
	 * @tparam V The element value type.
	 * @tparam M The element membership type.
	 * @tparam Allocator The allocator type.
	 * @param lhs The left-hand set for the union.
	 * @param rhs The right-hand set for the union.
	 * @return A set which is the union of the two operands.
	*/
	template <template <typename> class Operation, class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
	requires fuzzy::numeric<V>&& std::floating_point<M>&& tconorm_type<Operation<M>>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> antecedent_union(fuzzy::scaled_antecedent<V, M, Container, Allocator> const& lhs, fuzzy::scaled_antecedent<V, M, Container, Allocator> const& rhs)
	{
		return fuzzy::set_union<Operation>(lhs.set(), rhs.set());
	}

	namespace operators { namespace tnorm
	{
	
		namespace algabraic_product
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> operator&(fuzzy::scaled_antecedent<V, M, Container, Allocator> const& lhs, fuzzy::scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return fuzzy::antecedent_intersection<fuzzy::algabraic_product>(lhs, rhs);
			}
		}

		namespace bounded_difference
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> operator&(fuzzy::scaled_antecedent<V, M, Container, Allocator> const& lhs, fuzzy::scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return fuzzy::antecedent_intersection<fuzzy::bounded_difference>(lhs, rhs);
			}
		}

		namespace drastic_product
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> operator&(fuzzy::scaled_antecedent<V, M, Container, Allocator> const& lhs, fuzzy::scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return fuzzy::antecedent_intersection<fuzzy::drastic_product>(lhs, rhs);
			}
		}

		namespace einstein_product
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> operator&(fuzzy::scaled_antecedent<V, M, Container, Allocator> const& lhs, fuzzy::scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return fuzzy::antecedent_intersection<fuzzy::einstein_product>(lhs, rhs);
			}
		}

		namespace hamacher_product
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> operator&(fuzzy::scaled_antecedent<V, M, Container, Allocator> const& lhs, fuzzy::scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return fuzzy::antecedent_intersection<fuzzy::hamacher_product>(lhs, rhs);
			}
		}

		namespace minimum
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> operator&(fuzzy::scaled_antecedent<V, M, Container, Allocator> const& lhs, fuzzy::scaled_antecedent<V, M, Container, Allocator> const& rhs)
			{
				return fuzzy::antecedent_intersection<fuzzy::minimum>(lhs, rhs);
			}
		}










	}}

}


#endif // FUZZY_OPERATORS_HPP