//  Copyright (c) 2025, Ben McCart
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.

#ifndef FUZZY_ALGORITHM_HPP
#define FUZZY_ALGORITHM_HPP

#include <cmath>
#include <cstdint>
#include <iterator>
#include <limits>
#include <memory>
#include <span>
#include <stack>

#include <fuzzy/concepts.hpp>
#include <fuzzy/element.hpp>
#include <fuzzy/math.hpp>
#include <fuzzy/norm_conorm.hpp>
#include <fuzzy/set.hpp>
#include <fuzzy/traits.hpp>

namespace fuzzy
{
	constexpr std::size_t linguistic_term_default_steps = 3ull;
	constexpr std::size_t linguistic_term_max_steps = 7ull;

	namespace detail
	{

		template <class V, class M, template <typename T, typename Alloc = std::allocator<T>> class Container, class Allocator = std::allocator<fuzzy::basic_element<V,M>>>
		class set_operation_value_sequence
		{
		public:
			using set_t = fuzzy::basic_set<V, M, Container, Allocator>;
			using element_t = typename set_t::element_type;
			using value_t = std::pair<element_t,element_t>;

			class value_step_iterator
			{
			public:
				using iterator_category = std::forward_iterator_tag;
				using value_type = element_t;
				using difference_type = std::ptrdiff_t;
				using pointer = value_type const*;
				using reference = value_type;
				using iter_impl_t = typename set_t::const_iterator;

				value_step_iterator() = delete;

				constexpr explicit value_step_iterator(iter_impl_t itr, set_t const& set) : itr_(itr), set_(&set), value_({ static_cast<V>(0), static_cast<M>(0) })
				{
					if (itr_ != cend(*set_))
						value_ = *itr_;
				}

				constexpr value_step_iterator(value_step_iterator const&) = default;


				constexpr value_step_iterator& operator++()
				{
					++itr_;
					if (itr_ != cend(*set_))
						value_ = *itr_;

					return *this; 
				}

				constexpr value_step_iterator operator++(int)
				{
					value_step_iterator retval = *this;
					++(*this);
					return retval;
				}

				constexpr bool operator!=(value_step_iterator const& o) const    { return !(*this == o);  }
				constexpr bool operator==(value_step_iterator const& o) const    { return itr_ == o.itr_; }

				constexpr reference operator*() const                            { return value_;         }
				constexpr pointer operator->() const                             { return &value_;        }

				void value(V v)
				{
					assert(v > itr_->value());
					auto next = [](iter_impl_t itr) { return ++itr; }(itr_);
					if (next == cend(*set_))
					{
						itr_ = next;
						value_ = element_t{ std::numeric_limits<V>::max(), std::numeric_limits<M>::quiet_NaN() };
					}
					else
					{
						value_ = element_t{ v, set_->membership(v) };
					}
				}

			private:
				iter_impl_t itr_;
				set_t const *set_;
				element_t value_;
			};

			class const_iterator 
			{
			public:
				using iterator_category = std::forward_iterator_tag;
				using value_type = value_t;
				using difference_type = std::ptrdiff_t;
				using pointer = value_t*;
				using reference = value_t;
				using iter_impl_t = typename set_t::const_iterator;
				using element_t = basic_element<V,M>;
				using segment_t = fuzzy::math::basic_segment<V, M>;

				const_iterator() = delete;

				constexpr explicit const_iterator(iter_impl_t a, set_t const &a_set, iter_impl_t b, set_t const &b_set)
					: a_(a, a_set)
					, a_end_(cend(a_set), a_set)
					, a_set_(&a_set) 
					, b_(b, b_set)
					, b_end_(cend(b_set), b_set)
					, b_set_(&b_set) {}

				constexpr const_iterator(const_iterator const&) = default;

				constexpr const_iterator& operator++()
				{
					if (a_ != a_end_ && b_ != b_end_)
					{
						V av = a_->value();
						V bv = b_->value();
						if (av < bv)
							advance_a();
						else if (bv < av)
							advance_b();
						else { advance_a(); advance_b(); }
					}
					else if (a_ != a_end_)
						advance_a();
					else if (b_ != b_end_)
						advance_b();

					 return *this; 
				}

				constexpr const_iterator operator++(int)
				{
					const_iterator retval = *this;
					++(*this);
					return retval; 
				}

				constexpr bool operator!=(const_iterator const& o) const { return !(*this == o); }
				constexpr bool operator==(const_iterator const& o) const
				{
					return (a_ == o.a_ && b_ == o.b_);
				}

				constexpr reference operator*() const
				{
					if (a_ != a_end_ && b_ != b_end_)
					{
						V av = a_->value();
						V bv = b_->value();
						if (av < bv)
							return value_t{ *a_, element_t{ av, b_set_->membership(av)} };
						else if (bv < av)
							return value_t{ element_t{ bv, a_set_->membership(bv)}, *b_ };
						else
							return value_t{ *a_, *b_ };
					}
					else if (a_ != a_end_)
						return value_t{ *a_, element_t{ a_->value(), b_set_->membership(a_->value())} };
					else if (b_ != b_end_)
						return value_t{ element_t{ b_->value(), a_set_->membership(b_->value()) }, * b_ };

					return value_t{ std::numeric_limits<V>::max(), std::numeric_limits<M>::quiet_NaN() };
				}
	
			private:
				constexpr bool end_match(element_t e, segment_t s) noexcept
				{
					return fuzzy::math::equivelant(e.value(), s.v0.value()) || fuzzy::math::equivelant(e.value(), s.v1.value());
				}

				constexpr void advance_a()
				{
					// FIXME: Update this to only use the natural segments (no calls to membership).
					auto const a_next = [](value_step_iterator itr) { return ++itr; }(a_);
					V const v0 = a_->value();
					V const v1 = [&]()
					{
						bool const anext = a_next != a_end_;
						bool const b = b_ != b_end_;
						if (anext && b)
							return std::min(a_next->value(), b_->value());
						else if (b)
							return b_->value();
						else if (anext)
							return a_next->value();
						else
							return a_->value();
					}();
					segment_t seg_a
					{ 
						*a_,
						element_t{ v1, a_set_->membership(v1) }
					};
					segment_t seg_b
					{
						element_t{ v0, b_set_->membership(v0) },
						element_t{ v1, b_set_->membership(v1) },
					};

					auto rm_current = relative_membership(seg_a.v0, seg_b.v0);
					auto rm_next = relative_membership(seg_a.v1, seg_b.v1);
					if (do_relative_memberships_intersect(rm_current, rm_next))
					{
						element_t intersec = intersection(seg_a, seg_b);
						bool const any_match = end_match(intersec, seg_a) || end_match(intersec, seg_b);
						if (any_match)
							a_ = a_next;
						else
							a_.value(intersec.value());
					}
					else
					{
						a_ = a_next;
					}
				}
				constexpr void advance_b()
				{
					// FIXME: Update this to only use the natural segments (no calls to membership).
					auto const b_next = [](value_step_iterator itr) { return ++itr; }(b_);
					V const v0 = b_->value();
					V const v1 = [&]() -> V
					{
						bool const a = a_ != a_end_;
						bool const bnext = b_next != b_end_;
						if (bnext && a)
							return std::min(b_next->value(), a_->value());
						else if (a)
							return a_->value();
						else if (bnext)
							return b_next->value();
						else
							return b_->value();
					}();
					segment_t seg_a
					{
						element_t{ v0, a_set_->membership(v0) },
						element_t{ v1, a_set_->membership(v1) }
					};
					segment_t seg_b
					{
						*b_,
						element_t{ v1, b_set_->membership(v1) },
					};

					auto rm_current = relative_membership(seg_a.v0, seg_b.v0);
					auto rm_next = relative_membership(seg_a.v1, seg_b.v1);
					if (do_relative_memberships_intersect(rm_current, rm_next))
					{
						element_t intersec = intersection(seg_a, seg_b);
						bool const any_match = end_match(intersec, seg_a) || end_match(intersec, seg_b);
						if (any_match)
							b_ = b_next;
						else
							b_.value(intersec.value());
					}
					else
					{
						b_ = b_next;
					}
				}

				constexpr static int relative_membership(element_t e0, element_t e1)
				{
					if (e0.membership() < e1.membership())
						return -1;
					else if (e0.membership() > e1.membership())
						return 1;
					else return 0;
				}

				constexpr static bool do_relative_memberships_intersect(int rm0, int rm1)
				{
					int const result = rm0 - rm1;
					return (result == -2 || result == 2);
				}

				value_step_iterator a_;
				value_step_iterator const a_end_;
				set_t const *a_set_;
				value_step_iterator b_;
				value_step_iterator const b_end_;
				set_t const *b_set_;
			};
			
			
			set_operation_value_sequence() = delete;
			constexpr set_operation_value_sequence(set_t const& a, set_t const& b) : a_(a), b_(b) {}

			constexpr const_iterator begin() const
			{
				return const_iterator{ fuzzy::cbegin(a_), a_, fuzzy::cbegin(b_), b_};
			}

			constexpr const_iterator end() const
			{
				return const_iterator{ fuzzy::cend(a_), a_, fuzzy::cend(b_), b_ };
			}

		private:

			set_t const& a_;
			set_t const& b_;
		};

		template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
		constexpr typename set_operation_value_sequence<V, M, Container>::iterator begin(set_operation_value_sequence<V, M, Container, Allocator> const& set) { return set.begin(); }

		template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
		constexpr typename set_operation_value_sequence<V, M, Container>::iterator end(set_operation_value_sequence<V, M, Container, Allocator> const& set)   { return set.end();   }

		struct trim
		{
			template <class V, class M, template <typename T, typename Alloc> class Container>
			constexpr static void apply(fuzzy::basic_set<V, M, Container>& v)
			{
				constexpr M zero_m = static_cast<M>(0);
				if (v.size() < 3ull)
					return;

				auto ritr = cend(v) - 1ull;
				auto ritr_next = ritr - 1ull;
				for (; ritr->membership() == zero_m && ritr_next != cbegin(v) && ritr_next->membership() == zero_m; ritr = v.erase(ritr) - 1ull, ritr_next = ritr - 1ull) {}

				auto itr = cbegin(v);
				auto itr_next = itr + 1ull;
				for (; itr->membership() == zero_m && (cend(v) - itr_next) > 1ull && itr_next->membership() == zero_m; itr = v.erase(itr), itr_next = itr + 1ull) {}
			}


		};



		/**
		 * @brief A utility class for simplifying a fuzzy set.
		 * @tparam M Floating-point type used for membership.
		 * @tparam V Integral type used for value.
		 * @tparam Container The container type used for the set.
		*/
		template <class V, class M, template <typename T, typename Alloc> class Container>
		requires fuzzy::numeric<V> && std::floating_point<M>
		class simplify_impl
		{
		private:
			using set_t = basic_set<V, M, Container>;
			using element_t = basic_element<V, M>;
			using iterator = typename set_t::iterator;

			struct state_t
			{
				iterator dst;
				iterator prev;
				iterator itr;
				iterator next;
				iterator last;
				iterator end;
			};

			constexpr static iterator find_first(set_t &set)
			{
				constexpr M zero = static_cast<M>(0);
				iterator itr = std::find_if(set.begin(), set.end(), [](element_t const& e) -> bool { return e.membership() != zero; });
				if (itr != set.begin())
					--itr;

				return itr;
			}

			constexpr static iterator find_last(set_t& set)
			{
				constexpr M zero = static_cast<M>(0);
				auto itr = std::find_if(set.rbegin(), set.rend(), [](element_t const& e) -> bool { return e.membership() != zero; });
				if (itr != set.rbegin())
					--itr;

				return itr.base();
			}

			constexpr static bool check_range(set_t& set, iterator first, iterator last)
			{
				if (last - first < 3)
				{
					auto itr = last;
					if (first != set.begin())
					{
						std::copy(first, last, set.begin());
						itr = set.begin() + (last - first);
					}
					set.erase(itr, set.end());
					return false;
				}

				return true;
			}

			constexpr static M slope(fuzzy::basic_element<V, M> p0, fuzzy::basic_element<V, M> p1)
			{
				M const dx = static_cast<M>(p1.value() - p0.value());
				M const inv_denom = static_cast<M>(1) / dx;
				M const dy = p1.membership() - p0.membership();
				return dy * inv_denom;
			}

			constexpr static bool erase_predicate(iterator const& prev, iterator const& itr, iterator const& next) noexcept
			{
				if constexpr (std::floating_point<V>)
				{
					constexpr M value_spacing_multiplier = static_cast<M>(16);
					constexpr M vro = value_spacing_multiplier * fuzzy::math::detail::round_off<M>();
					if (fuzzy::math::equivelant(itr->value(), next->value(), vro))
					{
						constexpr M inv_div_2 = static_cast<M>(0.5l);
						V const v = static_cast<V>(fuzzy::math::round<V>(static_cast<M>(itr->value() + next->value()) * inv_div_2));
						M const m = (itr->membership() + next->membership()) * inv_div_2;
						next->value(v);
						next->membership(m);
						return true;
					}
				}
				else
				{
					if (itr->value() == next->value())
						return true;
				}

				M const s0 = slope(*prev, *itr);
				M const s1 = slope(*itr, *next);
				constexpr M slope_multiplier = static_cast<M>(5);
				constexpr M sro = slope_multiplier * fuzzy::math::detail::round_off<M>();
				if (fuzzy::math::equivelant(s0, s1, sro))
				{
					return true;
				}

				return false;
			}

			constexpr static void finish_prev(state_t& state)
			{
				assert(state.next == state.last);
				assert(state.itr + 1 == state.last);
				state.itr = state.last;
				for (;state.prev != state.last; ++state.prev)
				{
					if (state.dst != state.end && state.dst < state.prev)
					{
						assert(state.dst < state.prev);
						*state.dst = std::move(*state.prev);
						++state.dst;
					}
				}
			}

			constexpr static void advance_prev(state_t& state)
			{
				if (state.dst != state.end && state.dst < state.prev)
				{
					*state.dst = std::move(*state.prev);
					++state.dst;
				}

				state.prev = state.itr;
				state.itr = state.next;
				assert(state.next < state.last);
				++state.next;
				if (state.next == state.last)
					finish_prev(state);
			}

			constexpr static void advance_itr(state_t& state)
			{
				assert(state.itr < state.next && state.next < state.last);
				if (state.dst == state.end)
					state.dst = state.itr;

				++state.itr;
				++state.next;
				if (state.next == state.last)
					finish_prev(state);
			}

		public:

			/**
			 * @brief The effect is to remove fuzzy values that are co-linear with values before and after.
			 *        Value pairs that are to close (floating point) are averaged.
			 * @param set The set to simplify in-place.
			*/
			constexpr static void apply(set_t& set)
			{
				// Check sizes and initial state.
				constexpr M zero = static_cast<M>(0);
				if (set.size() == 2u && set.front().membership() == zero && set.back().membership() == zero)
					set.clear(); // The set is indistinguishable from empty if both values are zero.

				if (set.size() < 3u)
					return; // No simplification is possible.

				iterator first = find_first(set);
				iterator last = find_last(set);
				if (!check_range(set, first, last))
					return;

				iterator const beg = set.begin();
				iterator const end = set.end();
				state_t state
				{
					.dst = (first == beg) ? end : beg,
					.prev = first,
					.itr = first + 1,
					.next = first + 2,
					.last = last,
					.end = end
				};

				for (; state.prev != state.last;)
				{
					assert(state.prev < state.itr && state.itr + 1 == state.next && state.next != state.last);
					if (erase_predicate(state.prev, state.itr, state.next))
						advance_itr(state);
					else
						advance_prev(state);
				}

				assert(state.prev == state.last && state.itr == state.last && state.next == state.last);
				if (state.dst != end)
					set.erase(state.dst, end);
			}
		};

		template <template <typename> class Operation>
		struct operation
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			requires (fuzzy::tnorm_type<Operation<M>> || fuzzy::tconorm_type<Operation<M>>) && std::floating_point<M>
			[[nodiscard]] constexpr static fuzzy::basic_set<V, M, Container, Allocator> apply(fuzzy::basic_set<V, M, Container, Allocator> const& a, fuzzy::basic_set<V, M, Container, Allocator> const& b)
			{
				using set_t = fuzzy::basic_set<V, M, Container, Allocator>;
				using element_t = typename set_t::element_type;
				using op_t = Operation<M>;
				using pair_t = typename set_operation_value_sequence<V, M, Container, Allocator>::value_t;

				set_t result{ b.get_allocator() };
				std::size_t const max_size = std::max(a.size(), b.size());
				std::size_t const half_max_size = max_size / 2u;
				std::size_t const capacity = a.size() + b.size() + half_max_size;
				result.reserve(capacity);

				set_operation_value_sequence<V, M, Container> seq{ a, b };
				for (pair_t pair : seq)
				{
					V v = pair.first.value();
					M m = op_t::apply(pair.first.membership(), pair.second.membership());
					result.insert(element_t{ v, m });
				}
				detail::simplify_impl<V, M, Container>::apply(result); // NOTE: This is not merely a space optimization, it is for correctness with mapping rules.

				return result;
			}
		};

		template <class V, class VF>
		requires ValueFunction<VF, V>
		V values(V a, V b, VF vf)
		{
			return vf(a, b);
		}

		/* Triangular conorm function object.**/
		template <typename M = float>
		requires std::floating_point<M>
		class tconorm_binder
		{
		public:
			using tconorm = tconorm_tag;
			using value_type = M;
			using func_ptr = M(*)(M x, M y);

			tconorm_binder() { func_ = [](M, M) { return std::numeric_limits<M>::quiet_NaN(); }; }
			tconorm_binder(tconorm_binder<M> const&) = delete;
			tconorm_binder(tconorm_binder<M>&&) = delete;
			tconorm_binder<M>& operator=(tconorm_binder<M> const&) = delete;
			tconorm_binder<M>& operator=(tconorm_binder<M>&&) = delete;

			/** binds to a specific tconorm type */
			template <typename T>
			requires tconorm_type<T>
			constexpr void bind(T) noexcept
			{
				func_ = [](M x, M y) -> M { return T::apply(x, y); };
			}

			[[nodiscard]] constexpr M apply(M x, M y) noexcept
			{
				validate_range<M>(x, y);
				return func_(x, y);
			}

		private:
			func_ptr func_ = nullptr;
		};

		/* Triangular conorm function object.**/
		template <class M = float>
		requires std::floating_point<M>
		class tnorm_binder
		{
		public:
			using tnorm = tnorm_tag;
			using func_ptr = M(*)(M x, M y);

			tnorm_binder() { func_ = [](M, M) { return std::numeric_limits<M>::quiet_NaN(); }; }
			tnorm_binder(tnorm_binder<M> const&) = delete;
			tnorm_binder(tnorm_binder<M>&&) = delete;
			tnorm_binder<M>& operator=(tnorm_binder<M> const&) = delete;
			tnorm_binder<M>& operator=(tnorm_binder<M>&&) = delete;

			/** binds to a specific tconorm type */
			template <class T>
			requires tnorm_type<T>
			constexpr void bind(T) noexcept
			{
				func_ = [](M x, M y) -> M { return T::apply(x, y); };
			}

			[[nodiscard]] constexpr M apply(M x, M y) noexcept
			{
				validate_range<M>(x, y);
				return func_(x, y);
			}

		private:
			func_ptr func_;
		};

		template <class V, class M>
		requires fuzzy::numeric<V> && std::floating_point<M>
		struct edge
		{
			basic_element<V, M> v0;
			basic_element<V, M> v1;
		};

		template <class V, class M>
		requires fuzzy::numeric<V> && std::floating_point<M>
		constexpr std::span<fuzzy::basic_element<V, M>> calculate_linear_steps(fuzzy::basic_element<V,M> le, fuzzy::basic_element<V, M> re, std::span<fuzzy::basic_element<V, M>> steps)
		{
			using math::promote;
			M const dy = re.membership() - le.membership();
			M const dx = static_cast<M>(promote(re.value()) - promote(le.value()));
			M const lm = dy / dx;
			M const lb = le.membership() - (lm * static_cast<M>(le.value()));

			M const step_size = dx / static_cast<M>(steps.size() + 1ull);
			M step_x = step_size + static_cast<M>(le.value());
			for (auto itr = begin(steps); itr != end(steps); ++itr, step_x += step_size)
			{
				const M x = fuzzy::math::round<V>(step_x);
				const M m = (lm * x) + lb;
				const V v = static_cast<V>(x);
				*itr = fuzzy::basic_element<V, M>{ v, m };
			}

			return steps;
		};

		template <class Func, class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc> class Container, class Allocator>
		requires fuzzy::numeric<V> && std::floating_point<M>
		[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> linguistic_term_impl(fuzzy::basic_set<V, M, Container, Allocator> const& aset, Func const& func, std::size_t step_count = linguistic_term_default_steps)
		{
			using math::promote;
			using set_type = fuzzy::basic_set<V, M, Container, Allocator>;
			using element_type = typename set_type::element_type;
			set_type result;

			constexpr M min_threshold = static_cast<M>(0.25);
			constexpr M max_threshold = static_cast<M>(0.95);

			// Handle special cases of empty or 1 element.
			if (aset.empty())
			{
				return result;
			}
			if (aset.size() == 1ull)
			{
				element_type e = aset.front();
				e.membership(std::sqrt(e.membership()));
				result.insert(std::move(e));
			}

			std::array<element_type, linguistic_term_max_steps> buffer = 
			{ 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0} 
			};
			auto calc_steps = [&](element_type lhs, element_type rhs) -> std::size_t
			{
				assert(rhs.value() > lhs.value());
				std::size_t const steps = std::min(static_cast<std::size_t>(rhs.value() - lhs.value()) - 1ull, step_count);
				return std::min(steps, buffer.size());
			};

			// Handle the general case.
			auto itr_last = begin(aset);
			assert(itr_last != end(aset));
			for (auto itr = itr_last + 1; itr != end(aset); ++itr_last, ++itr)
			{
				result.insert(element_type{ itr_last->value(), func(itr_last->membership()) });

				M const lm = itr_last->membership();
				M const rm = itr->membership();
				if ((lm > max_threshold && rm < min_threshold) || (lm < min_threshold && rm > max_threshold))
				{
					std::span<element_type> steps = calculate_linear_steps(
						*itr_last,
						*itr,
						std::span<element_type>{ buffer.data(), buffer.data() + calc_steps(*itr_last, *itr) });
					for (auto e : steps)
					{
						result.insert(element_type{ e.value(), func(e.membership()) });
					}
				}
			}
			return result;
		}

	}

	/**
	 * @brief A version of std::set_intersection compatible with fuzzy set theory.
	 * @tparam V The element value type.
	 * @tparam M The element membership type.
	 * @tparam Allocator The allocator type.
	 * @param lhs The left-hand set for the intersection.
	 * @param rhs The right-hand set for the intersection.
	 * @return A set which is the intersection of the two operands.
	*/
	template <template<typename> class Operation, class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
	requires fuzzy::numeric<V> && std::floating_point<M> && tnorm_type<Operation<M>>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> set_intersection(fuzzy::basic_set<V, M, Container, Allocator> const& lhs, fuzzy::basic_set<V, M, Container, Allocator> const& rhs)
	{
		return fuzzy::detail::operation<Operation>::apply(lhs, rhs);
	}

	/**
	 * @brief A version of std::set_union compatible with fuzzy set theory.
	 * @tparam V The element value type.
	 * @tparam M The element membership type.
	 * @tparam Allocator The allocator type.
	 * @param lhs The left-hand set for the union.
	 * @param rhs The right-hand set for the union.
	 * @return A set which is the union of the two operands.
	*/
	template <template <typename> class Operation, class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
	requires fuzzy::numeric<V> && std::floating_point<M> && tconorm_type<Operation<M>>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> set_union(fuzzy::basic_set<V, M, Container, Allocator> const& lhs, fuzzy::basic_set<V, M, Container, Allocator> const& rhs)
	{
		return fuzzy::detail::operation<Operation>::apply(lhs, rhs);
	}

	// Complement function object.
	template <typename M = float>
	requires std::floating_point<M>
	struct complement
	{
		using value_type = M;

		// Complement as 1 - m.
		// @param m Membership in the range [0,1].
		// @result a value in the range [0,1].
		[[nodiscard]] constexpr static M apply(M m) noexcept
		{
			validate_range<M>(m);
			return static_cast<M>(1.0) - m;
		}
	};

	/**
	* Complement of fuzzy set.
	* @param aset The set to complement.
	* @return The complement of the set.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc = std::allocator<T>> class Container>
	requires fuzzy::numeric<V> && std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> set_complement(fuzzy::basic_set<V, M, Container> const& aset)
	{
		using set_type = fuzzy::basic_set<V, M, Container>;
		using element_type = typename set_type::element_type;
		set_type result;

		constexpr V v_min = std::numeric_limits<V>::lowest();
		constexpr V v_max = std::numeric_limits<V>::max();
		constexpr V v_offset = static_cast<V>(1);
		constexpr M m_max = static_cast<M>(1.0);
		constexpr M m_min = static_cast<M>(0.0);
		constexpr complement<M> comp;

		if (aset.empty())
		{
			result.insert(element_type{ v_min, m_max });
			result.insert(element_type{ v_max, m_max });
			return result;
		}

		M const m_front = comp.apply(aset.front().membership());
		if (m_front != m_min && aset.front().value() != v_min)
		{
			V const v_prefix = aset.front().value() - v_offset;
			if (v_prefix != v_min)
				result.insert(element_type{ v_min, m_max });

			if (m_front != m_min)
				result.insert(element_type{ v_prefix, m_max });
		}

		for (auto& element : aset)
		{
			result.insert(fuzzy::basic_element<V, M>{ element.value(), comp.apply(element.membership()) });
		}

		M const m_back = result.back().membership();
		if (m_back != m_min && aset.back().value() != v_max)
		{
			V const v_postfix = aset.back().value() + v_offset;
			if (v_postfix != v_max)
				result.insert(element_type{ v_max, m_max });

			if (m_back != m_min)
				result.insert(element_type{ v_postfix, m_max });
		}

		return result;
	}
}

#endif // FUZZY_ALGORITHM_HPP