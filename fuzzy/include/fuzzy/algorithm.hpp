//  Copyright (c) 2025, Ben McCart
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.

#ifndef FUZZY_ALGORITHM_HPP
#define FUZZY_ALGORITHM_HPP

#include <cmath>
#include <cstdint>
#include <iterator>
#include <limits>
#include <memory>
#include <memory_resource>
#include <optional>
#include <span>
#include <stack>

#include <fuzzy/concepts.hpp>
#include <fuzzy/element.hpp>
#include <fuzzy/math.hpp>
#include <fuzzy/norm_conorm.hpp>
#include <fuzzy/set.hpp>
#include <fuzzy/traits.hpp>

namespace fuzzy
{
	constexpr std::size_t linguistic_term_default_steps = 3ull;
	constexpr std::size_t linguistic_term_max_steps = 7ull;

	namespace detail
	{

		template <class V, class M, template <typename T, typename Alloc = std::allocator<T>> class Container, class Allocator = std::allocator<fuzzy::basic_element<V,M>>>
		class set_operation_value_sequence
		{
		public:
			using set_t = fuzzy::basic_set<V, M, Container, Allocator>;
			using element_t = typename set_t::element_type;
			using value_t = std::pair<element_t,element_t>;

			class value_step_iterator
			{
			public:
				using iterator_category = std::forward_iterator_tag;
				using value_type = element_t;
				using difference_type = std::ptrdiff_t;
				using pointer = value_type const*;
				using reference = value_type;
				using iter_impl_t = typename set_t::const_iterator;

				value_step_iterator() = delete;

				constexpr explicit value_step_iterator(iter_impl_t itr, set_t const& set) : itr_(itr), set_(&set), value_({ static_cast<V>(0), static_cast<M>(0) })
				{
					if (itr_ != cend(*set_))
						value_ = *itr_;
				}

				constexpr value_step_iterator(value_step_iterator const&) = default;


				constexpr value_step_iterator& operator++()
				{
					++itr_;
					if (itr_ != cend(*set_))
						value_ = *itr_;

					return *this; 
				}

				constexpr value_step_iterator operator++(int)
				{
					value_step_iterator retval = *this;
					++(*this);
					return retval;
				}

				constexpr bool operator!=(value_step_iterator const& o) const    { return !(*this == o);  }
				constexpr bool operator==(value_step_iterator const& o) const    { return itr_ == o.itr_; }

				constexpr reference operator*() const                            { return value_;         }
				constexpr pointer operator->() const                             { return &value_;        }

				void value(V /*v*/)
				{
					//assert(v > itr_->value());
					//auto next = [](iter_impl_t itr) { return ++itr; }(itr_);
					//if (next == cend(*set_))
					//{
					//	itr_ = next;
					//	value_ = element_t{ std::numeric_limits<V>::max(), std::numeric_limits<M>::quiet_NaN() };
					//}
					//else
					//{
					//	value_ = element_t{ v, set_->membership(v) };
					//}
				}

			private:
				iter_impl_t itr_;
				set_t const *set_;
				element_t value_;
			};

			class const_iterator
			{
			public:
				using iterator_category = std::forward_iterator_tag;
				using value_type = value_t;
				using difference_type = std::ptrdiff_t;
				using pointer = value_t*;
				using reference = value_t;
				using iter_impl_t = typename set_t::const_iterator;
				using element_t = basic_element<V, M>;
				using segment_t = fuzzy::math::basic_segment<V, M>;
				using optional_element_t = std::optional<element_t>;

				const_iterator() = delete;

				constexpr explicit const_iterator(iter_impl_t a, set_t const& a_set, iter_impl_t b, set_t const& b_set)
					: a_(a)
					, a_end_(a_set.cend())
					, a_set_(&a_set)
					, b_(b)
					, b_end_(b_set.cend())
					, b_set_(&b_set)
					, last_(find_first(a, a_set.cend(), b, b_set.cend()))
					, a_value_(bad_value())
					, b_value_(bad_value())
				{
					if (a_ != a_end_ && (b_ == b_end_ || a_->value() <= b_->value()))
						set_values(a_, b_end_);
					if (b_ != b_end_ && (a_ == a_end_ || a_->value() >= b_->value()))
						set_values(a_end_, b_);

					if (!((a_value_ != bad_value() && b_value_ != bad_value()) || (a_ == a_end_ && b_ == b_end_)))
					{
						[[maybe_unused]] bool break_here = true;
					}
					assert((a_value_ != bad_value() && b_value_ != bad_value()) || (a_ == a_end_ && b_ == b_end_));
				}

				constexpr const_iterator(const_iterator const&) = default;

				constexpr const_iterator& operator++()
				{
					advance adv = determin_advance();
					switch (adv)
					{
						case advance::to_a: advance_to_a(); break;
						case advance::to_b: advance_to_b(); break;
						case advance::a_to_next:  advance_a_to_next(); break;
						case advance::b_to_next:  advance_b_to_next(); break;
						case advance::a_and_b_to_next: advance_a_and_b_to_next(); break;
						case advance::a_to_end: advance_a_to_end(); break;
						case advance::b_to_end: advance_b_to_end(); break;
						case advance::a_and_b_to_end: advance_a_and_b_to_end(); break;

						//case advance::a_and_b:
						//	advance_a();
						//	advance_b();
						//	break;
					}

					return *this; 
				}

				constexpr const_iterator operator++(int)
				{
					const_iterator retval = *this;
					++(*this);
					return retval; 
				}

				constexpr bool operator!=(const_iterator const& o) const { return !(*this == o); }
				constexpr bool operator==(const_iterator const& o) const
				{
					return (a_ == o.a_ && b_ == o.b_);
				}

				constexpr reference operator*()
				{
					return dref_impl();
					//last_v_ = ref.first.value();
					//return ref;
				}

				//constexpr reference operator*() const
				//{
				//	??	
				//}

	
			private:

				enum class advance
				{
					to_a,
					to_b,
					a_to_end,
					b_to_end,
					a_and_b_to_end,
					a_to_next,
					b_to_next,
					a_and_b_to_next
				};

				enum class iterator_tag
				{
					a_next = 1,
					b_next,
					a,
					b,
				};

				static constexpr element_t bad_value() noexcept
				{
					element_t bad{ std::numeric_limits<V>::max(), static_cast<M>(0) };
					bad.membership(-1);
					return bad;
				}

				static constexpr advance tag_to_end(iterator_tag tag) noexcept
				{
					assert(tag == iterator_tag::a || tag == iterator_tag::b);
					return (tag == iterator_tag::a) ? advance::a_to_end : advance::b_to_end;
				}

				static constexpr advance tag_to_advance(iterator_tag tag) noexcept
				{
					switch (tag)
					{
						case iterator_tag::a: return advance::to_a;
						case iterator_tag::a_next: return advance::a_to_next;
						case iterator_tag::b: return advance::to_b;
						case iterator_tag::b_next: return advance::b_to_next;
					}

					assert(!"invalid enumerated value");
					return advance::a_and_b_to_end;
				}

				static constexpr advance tag_to_advance(iterator_tag n, iterator_tag an) noexcept
				{
					if ((n == iterator_tag::a_next && an == iterator_tag::b_next) ||
						(n == iterator_tag::b_next && an == iterator_tag::a_next))
					{
						return advance::a_and_b_to_next;
					}

					return tag_to_advance(n);
				}

				

				struct advance_data
				{
					iter_impl_t itr;
					iterator_tag tag;
				};

				constexpr reference dref_impl() const
				{
					if (intersection_)
						return value_t{ *intersection_, *intersection_ };
					else
					{
						assert(a_value_.value() == b_value_.value());
						return value_t{ a_value_, b_value_ };
					}

					//if (a_ != a_end_ && b_ != b_end_)
					//{
					//	V av = a_->value();
					//	V bv = b_->value();

					//	M am = a_->membership();
					//	M bm = b_->membership();

					//	if (av <= last_v_)
					//	{
					//		av = last_v_;
					//		am = a_set_->membership(av);
					//	}
					//	if (bv <= last_v_)
					//	{
					//		bv = last_v_;
					//		bm = b_set_->membership(bv);
					//	}

					//	if (av < bv)
					//		return value_t{ element_t{av, am}, element_t{av, b_set_->membership(av)} };
					//	else if (bv < av)
					//		return value_t{ element_t{bv, a_set_->membership(bv)}, element_t{bv, bm} };
					//	else
					//		return value_t{ element_t{av, am}, element_t{bv, bm} };
					//}
					//else if (a_ != a_end_)
					//	return value_t{ *a_, element_t{ a_->value(), b_set_->membership(a_->value())} };
					//else if (b_ != b_end_)
					//	return value_t{ element_t{ b_->value(), a_set_->membership(b_->value()) }, *b_ };

					//return value_t{ std::numeric_limits<V>::max(), std::numeric_limits<M>::quiet_NaN() };
				}

				constexpr static void push_back(std::array<advance_data, 4>& data, std::size_t& data_size, advance_data&& adv)
				{
					data.at(data_size) = std::move(adv);
					++data_size;
				}

				constexpr advance determin_advance() const
				{
					assert(a_ != a_end_ || b_ != b_end_);

					// Add and sort relevant data (NOTE: Replace this with pmr::monotonic_buffer_resource when migrating to C++26)
					std::array<advance_data, 4> data_buffer;
					std::size_t data_size = 0u;

					iter_impl_t const a_next = (a_ != a_end_) ? (a_ + 1) : a_end_;
					iter_impl_t const b_next = (b_ != b_end_) ? (b_ + 1) : b_end_;
					if (a_ != a_end_)
						push_back(data_buffer, data_size, advance_data{ a_, iterator_tag::a });
					if (a_next != a_end_)
						push_back(data_buffer, data_size, advance_data{ a_next, iterator_tag::a_next });
					if (b_ != b_end_)
						push_back(data_buffer, data_size, advance_data{ b_, iterator_tag::b });
					if (b_next != b_end_)
						push_back(data_buffer, data_size, advance_data{ b_next, iterator_tag::b_next });

					// Handle special case where we are completing a single side.
					std::span<advance_data> data{ data_buffer.data(), data_size };
					assert(!data.empty());
					if (data.size() == 1u)
						return tag_to_end(data.front().tag);

					// Find the first item that is greater than 'last'
					std::sort(data.begin(), data.end(), [](advance_data const& lhs, advance_data const& rhs) -> bool
					{
						if (lhs.itr->value() == rhs.itr->value())
							return lhs.tag < rhs.tag;

						return lhs.itr->value() < rhs.itr->value();
					});
					auto const next = std::find_if(data.begin(), data.end(), [&](advance_data const item) -> bool
					{
						return item.itr->value() > last_->value();
					});

					// Handle special case where we are at the end.
					if (next == data.end())
					{
						assert((next - 1)->itr->value() == last_->value());
						return advance::a_and_b_to_end;
					}

					assert(next != data.begin());
					assert((next-1)->itr->value() == last_->value());
					assert(next->itr->value() > last_->value());

					// Check for the simple case where there is only one matching value.
					auto after_next = (next+1);
					if (after_next == data.end())
						return tag_to_advance(next->tag);

					// Check for the next simplest case where the next two values don't match.
					if (next->itr->value() != after_next->itr->value())
						return tag_to_advance(next->tag);

					// Handle the complex case where values match and we need to see if they are the same category.
					return tag_to_advance(next->tag, after_next->tag);



					//// Check for advancing to a/b.
					//if (a_ != a_end_ && last_->value() < a_->value())
					//	return advance_option::advance_to_a;
					//if (b_ != b_end_ && last_->value() < b_->value())
					//	return advance_option::advance_to_b;

					//// Check special end conditions for special handling.
					//if (a_next == a_end_ && b_next == b_end_)
					//{
					//	if (a_ == a_end_)
					//		return advance_option::advance_b_to_next;
					//	if (b_ == b_end_)
					//		return advance_option::advance_a_to_next;

					//	return advance_option::a_and_b; // FIXME: Maybe simpler to just have a 'complete' function?
					//}
					//if (a_next != a_end_ && b_next == b_end_)
					//{
					//	if (b_ == b_end_)
					//		return advance_option::advance_a_to_next;
					//	if (a_->value() < b_->value())
					//		return advance_option::a_only;
					//	if (b_->value() < a_->value())
					//		return advance_option::b_only;

					//	return advance_option::a_and_b;
					//}
					//if (b_next != b_end_ && a_next == a_end_)
					//{
					//	if (a_ == a_end_)
					//		return advance_option::b_only;
					//	if (b_->value() < a_->value())
					//		return advance_option::b_only;
					//	if (a_->value() < b_->value())
					//		return advance_option::a_only;

					//	return advance_option::a_and_b;
					//}

					//// Normal logic 
					//if (a_next->value() < b_next->value())
					//	return advance_option::a_only;
					//if (b_next->value() < a_next->value())
					//	return advance_option::b_only;

					//return advance_option::a_and_b;
				}

				constexpr void set_values(iter_impl_t a, iter_impl_t b)
				{
					if (a != a_end_)
					{
						a_ = a;
						last_ = a;
						a_value_ = element_t{ *a };
					}
					else
					{
						assert(b != b_end_);
						a_value_ = element_t{ b->value(), a_set_->membership(b->value()) };
					}

					if (b != b_end_)
					{
						b_ = b;
						last_ = b;
						b_value_ = element_t{ *b };
					}
					else
					{
						assert(a != a_end_);
						b_value_ = element_t{ a->value(), b_set_->membership(a->value()) };
					}
				}

				constexpr iter_impl_t find_first(iter_impl_t const &a, iter_impl_t const &a_end, iter_impl_t const &b, iter_impl_t const &b_end)
				{
					if (a == a_end && b == b_end)
						return a;
					if (a == a_end)
						return b;
					if (b == b_end)
						return a;

					return (a->value() < b->value()) ? a : b;
				}

				constexpr bool end_match(element_t e, segment_t s) noexcept // FIXME: Is this even used?
				{
					return fuzzy::math::equivelant(e.value(), s.v0.value()) || fuzzy::math::equivelant(e.value(), s.v1.value());
				}

				constexpr void advance_a_to_end()
				{
					a_ = a_end_;
				}

				constexpr void advance_b_to_end()
				{
					b_ = b_end_;
				}

				constexpr void advance_a_and_b_to_end()
				{
					advance_a_to_end();
					advance_b_to_end();
				}

				constexpr void advance_to_a()
				{
					set_values(a_, b_end_);
				}

				constexpr void advance_to_b()
				{
					set_values(a_end_, b_);
				}

				constexpr void advance_a_to_next()
				{
					assert(a_ != a_end_);
					iter_impl_t const a_next = a_ + 1;
					iter_impl_t const b_next = (b_ == b_end_) ? b_ : b_ + 1;
					assert(a_next != a_end_);

					if (b_next == b_end_)
					{
						intersection_.reset();
						set_values(a_next, b_end_);
						return; // Completing 'a'.
					}

					if (intersection_)
					{
						intersection_.reset();
						set_values(a_next, b_end_);
						return; // Advance to next 'a' segment.
					}

					// Check for intersection on current 'a' segment.
					segment_t seg_a{ *a_, *a_next };
					segment_t seg_b{ *b_, *b_next };
					intersection_ = intersection(seg_a, seg_b);
					if (!intersection_)
					{
						// No intersection, advance to next 'a' segment.
						set_values(a_next, b_end_);
					}
				}

				constexpr void advance_b_to_next()
				{
					assert(b_ != b_end_);
					iter_impl_t const a_next = (a_ == a_end_) ? a_ : a_ + 1;
					iter_impl_t const b_next = b_ + 1;
					assert(b_next != b_end_);

					if (a_next == a_end_)
					{
						intersection_.reset();
						set_values(a_end_, b_next);
						return; // Completing 'b'
					}

					if (intersection_)
					{
						intersection_.reset();
						set_values(a_end_, b_next);
						return; // Advance to next 'b' segment.
					}

					// Check for intersection on current 'b' segment.
					segment_t seg_a{ *a_, *a_next };
					segment_t seg_b{ *b_, *b_next };
					intersection_ = intersection(seg_a, seg_b);
					if (!intersection_)
					{
						// No intersection, advance to next 'b' segment.
						set_values(a_end_, b_next);
					}
				}

				constexpr void advance_a_and_b_to_next()
				{
					assert(a_ != a_end_);
					assert(b_ != b_end_);
					iter_impl_t const a_next = a_ + 1;
					iter_impl_t const b_next = b_ + 1;
					assert(a_next != a_end_);
					assert(b_next != b_end_);

					if (intersection_)
					{
						intersection_.reset();
						set_values(a_next, b_next);
						assert(a_->value() == b_->value());
						return; // Advance to next 'b' segment.
					}

					// Check for intersection on current 'b' segment.
					segment_t seg_a{ *a_, *a_next };
					segment_t seg_b{ *b_, *b_next };
					intersection_ = intersection(seg_a, seg_b);
					if (!intersection_)
					{
						// No intersection, advance to next 'b' segment.
						set_values(a_next, b_next);
						assert(a_->value() == b_->value());
					}
				}

				//constexpr void advance_a()
				//{
				//	auto const a_next = [](value_step_iterator itr) { return ++itr; }(a_);
				//	auto const b_next = [&](value_step_iterator itr)
				//	{
				//		if (itr == b_end_) 
				//			return itr;

				//		return ++itr;
				//	}(b_);

				//	if (a_next == a_end_ || b_next == b_end_)
				//	{
				//		intersection_.reset();
				//		a_ = a_next;
				//		last_ = a_;
				//		return; // Completing 'a'.
				//	}

				//	if (intersection_)
				//	{
				//		intersection_.reset();
				//		a_ = a_next;
				//		last_ = a_;
				//		return; // Advance to next 'a' segment.
				//	}

				//	// Check for intersection on current 'a' segment.
				//	segment_t seg_a{ *a_, *a_next };
				//	segment_t seg_b{ *b_, *b_next };
				//	intersection_ = intersection(seg_a, seg_b);
				//	if (intersection_)
				//	{
				//		assert(!end_match(*intersection_, seg_a) && !end_match(*intersection_, seg_b));
				//		a_.value(intersection_->value());
				//	}
				//	else
				//	{
				//		// No intersection, advance to next 'a' segment.
				//		a_ = a_next;
				//		last_ = a_;
				//	}
				//}
				//constexpr void advance_b()
				//{
				//	auto const a_next = [&](value_step_iterator itr)
				//	{
				//		if (itr == a_end_)
				//			return itr;

				//		return ++itr;
				//	}(a_);
				//	auto const b_next = [](value_step_iterator itr) { return ++itr; }(b_);

				//	if (a_next == a_end_ || b_next == b_end_)
				//	{
				//		intersection_.reset();
				//		b_ = b_next;
				//		last_ = b_;
				//		return; // Completing 'b'
				//	}

				//	if (intersection_)
				//	{
				//		intersection_.reset();
				//		b_ = b_next;
				//		last_ = b_;
				//		return; // Advance to next 'b' segment.
				//	}

				//	// Check for intersection on current 'b' segment.
				//	segment_t seg_a{ *a_, *a_next };
				//	segment_t seg_b{ *b_, *b_next };
				//	intersection_ = intersection(seg_a, seg_b);
				//	if (intersection_)
				//	{
				//		assert(!end_match(*intersection_, seg_a) && !end_match(*intersection_, seg_b));
				//		b_.value(intersection_->value());
				//	}
				//	else
				//	{
				//		// No intersection, advance to next 'b' segment.
				//		b_ = b_next;
				//		last_ = b_;
				//	}
				//}

				//constexpr static int relative_membership(element_t e0, element_t e1)
				//{
				//	if (e0.membership() < e1.membership())
				//		return -1;
				//	else if (e0.membership() > e1.membership())
				//		return 1;
				//	else return 0;
				//}

				//constexpr static bool do_relative_memberships_intersect(segment_t const &seg_a, segment_t const &seg_b)
				//{
				//	assert(seg_a.v0.value() <= seg_a.v1.value());
				//	assert(seg_b.v0.value() <= seg_b.v1.value());
				//	if (seg_a.v1.value() <= seg_b.v0.value() || seg_b.v1 <= seg_a.v0.value())
				//		return false;

				//	auto const rm0 = relative_membership(seg_a.v0, seg_b.v0);
				//	auto const rm1 = relative_membership(seg_a.v1, seg_b.v1);
				//	int const result = rm0 - rm1;
				//	return (result == -2 || result == 2);
				//}

				//constexpr static optional_element_t find_intersection(segment_t const& seg_a, segment_t const& seg_b)
				//{
				//	return intersection(seg_a, seg_b);
				//}

				iter_impl_t a_;
				iter_impl_t const a_end_;
				set_t const *a_set_;
				iter_impl_t b_;
				iter_impl_t const b_end_;
				set_t const *b_set_;
				optional_element_t intersection_;
				iter_impl_t last_;
				element_t a_value_;
				element_t b_value_;
			};
			
			
			set_operation_value_sequence() = delete;
			constexpr set_operation_value_sequence(set_t const& a, set_t const& b) : a_(a), b_(b) {}

			constexpr const_iterator begin() const
			{
				return const_iterator{ fuzzy::cbegin(a_), a_, fuzzy::cbegin(b_), b_};
			}

			constexpr const_iterator end() const
			{
				return const_iterator{ fuzzy::cend(a_), a_, fuzzy::cend(b_), b_ };
			}

		private:

			set_t const& a_;
			set_t const& b_;
		};

		template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
		constexpr typename set_operation_value_sequence<V, M, Container>::iterator begin(set_operation_value_sequence<V, M, Container, Allocator> const& set) { return set.begin(); }

		template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
		constexpr typename set_operation_value_sequence<V, M, Container>::iterator end(set_operation_value_sequence<V, M, Container, Allocator> const& set)   { return set.end();   }

		struct trim
		{
			template <class V, class M, template <typename T, typename Alloc> class Container>
			constexpr static void apply(fuzzy::basic_set<V, M, Container>& v)
			{
				constexpr M zero_m = static_cast<M>(0);
				if (v.size() < 3ull)
					return;

				auto ritr = cend(v) - 1ull;
				auto ritr_next = ritr - 1ull;
				for (; ritr->membership() == zero_m && ritr_next != cbegin(v) && ritr_next->membership() == zero_m; ritr = v.erase(ritr) - 1ull, ritr_next = ritr - 1ull) {}

				auto itr = cbegin(v);
				auto itr_next = itr + 1ull;
				for (; itr->membership() == zero_m && (cend(v) - itr_next) > 1ull && itr_next->membership() == zero_m; itr = v.erase(itr), itr_next = itr + 1ull) {}
			}


		};



		/**
		 * @brief A utility class for simplifying a fuzzy set.
		 * @tparam M Floating-point type used for membership.
		 * @tparam V Integral type used for value.
		 * @tparam Container The container type used for the set.
		*/
		template <class V, class M, template <typename T, typename Alloc> class Container>
		requires fuzzy::numeric<V> && std::floating_point<M>
		class simplify_impl
		{
		private:
			using set_t = basic_set<V, M, Container>;
			using element_t = basic_element<V, M>;
			using iterator = typename set_t::iterator;

			struct state_t
			{
				iterator dst;
				iterator prev;
				iterator itr;
				iterator next;
				iterator last;
				iterator end;
			};

			constexpr static iterator find_first(set_t &set)
			{
				constexpr M zero = static_cast<M>(0);
				iterator itr = std::find_if(set.begin(), set.end(), [](element_t const& e) -> bool { return e.membership() != zero; });
				if (itr != set.begin())
					--itr;

				return itr;
			}

			constexpr static iterator find_last(set_t& set)
			{
				constexpr M zero = static_cast<M>(0);
				auto itr = std::find_if(set.rbegin(), set.rend(), [](element_t const& e) -> bool { return e.membership() != zero; });
				if (itr != set.rbegin())
					--itr;

				return itr.base();
			}

			constexpr static bool check_range(set_t& set, iterator first, iterator last)
			{
				if (last < first)
				{
					set.clear();
					return false;
				}

				if (last - first < 3)
				{
					auto itr = last;
					if (first != set.begin())
					{
						std::copy(first, last, set.begin());
						itr = set.begin() + (last - first);
					}
					set.erase(itr, set.end());
					return false;
				}

				return true;
			}

			constexpr static M slope(fuzzy::basic_element<V, M> p0, fuzzy::basic_element<V, M> p1)
			{
				M const dx = static_cast<M>(p1.value() - p0.value());
				M const inv_denom = static_cast<M>(1) / dx;
				M const dy = p1.membership() - p0.membership();
				return dy * inv_denom;
			}

			constexpr static bool erase_predicate(iterator const& prev, iterator const& itr, iterator const& next) noexcept
			{
				M const s0 = slope(*prev, *next);
				M const s1 = [&]()
				{
					V const dprev = itr->value() - prev->value();
					V const dnext = next->value() - itr->value();
					if (dnext > dprev)
						return slope(*itr, *next);
					else
						return slope(*prev, *itr);
				}();
				constexpr M slope_multiplier = static_cast<M>(5);
				constexpr M sro = slope_multiplier * fuzzy::math::detail::round_off<M>();
				if (fuzzy::math::equivelant(s0, s1, sro))
				{
					return true;
				}

				//if constexpr (std::floating_point<V>)
				//{
				//	constexpr M value_spacing_multiplier = static_cast<M>(16);
				//	constexpr M vro = value_spacing_multiplier * fuzzy::math::detail::round_off<M>();
				//	if (fuzzy::math::equivelant(itr->value(), next->value(), vro))
				//	{
				//		constexpr M inv_div_2 = static_cast<M>(0.5l);
				//		V const v = static_cast<V>(fuzzy::math::round<V>(static_cast<M>(itr->value() + next->value()) * inv_div_2));
				//		M const m = (itr->membership() + next->membership()) * inv_div_2;
				//		next->value(v);
				//		next->membership(m);
				//		return true;
				//	}
				//}
				//else
				//{
				//	if (itr->value() == next->value())
				//		return true;
				//}

				return false;
			}

			constexpr static void finish_prev(state_t& state)
			{
				assert(state.next == state.last);
				assert(state.itr + 1 == state.last);
				for (;state.prev != state.last;)
				{
					if (state.dst != state.end && state.dst < state.prev)
					{
						assert(state.dst < state.prev);
						*state.dst = std::move(*state.prev);
						++state.dst;
					}

					if (state.itr != state.last)
					{
						state.prev = state.itr;
						state.itr = state.next;
						assert(state.itr == state.last);
					}
					else
					{
						++state.prev;
					}
				}
			}

			constexpr static void advance_prev(state_t& state)
			{
				if (state.dst != state.end && state.dst < state.prev)
				{
					*state.dst = std::move(*state.prev);
					++state.dst;
				}

				state.prev = state.itr;
				state.itr = state.next;
				assert(state.next < state.last);
				++state.next;
				if (state.next == state.last)
					finish_prev(state);
			}

			constexpr static void advance_itr(state_t& state)
			{
				assert(state.itr < state.next && state.next < state.last);
				if (state.dst == state.end)
					state.dst = state.itr;

				++state.itr;
				++state.next;
				if (state.next == state.last)
					finish_prev(state);
			}

		public:

			/**
			 * @brief The effect is to remove fuzzy values that are co-linear with values before and after.
			 *        Value pairs that are to close (floating point) are averaged.
			 * @param set The set to simplify in-place.
			*/
			constexpr static void apply(set_t& set)
			{
				// Check sizes and initial state.
				constexpr M zero = static_cast<M>(0);
				if (set.size() == 2u && set.front().membership() == zero && set.back().membership() == zero)
					set.clear(); // The set is indistinguishable from empty if both values are zero.

				if (set.size() < 3u)
					return; // No simplification is possible.

				iterator first = find_first(set);
				iterator last = find_last(set);
				if (!check_range(set, first, last))
					return;

				iterator const beg = set.begin();
				iterator const end = set.end();
				state_t state
				{
					.dst = (first == beg) ? end : beg,
					.prev = first,
					.itr = first + 1,
					.next = first + 2,
					.last = last,
					.end = end
				};

				for (; state.prev != state.last;)
				{
					assert(state.prev < state.itr && state.itr + 1 == state.next && state.next != state.last);
					if (erase_predicate(state.prev, state.itr, state.next))
						advance_itr(state);
					else
						advance_prev(state);
				}

				assert(state.prev == state.last && state.itr == state.last && state.next == state.last);
				if (state.dst != end)
					set.erase(state.dst, end);
			}
		};

		template <template <typename> class Operation>
		struct operation
		{
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			requires (fuzzy::tnorm_type<Operation<M>> || fuzzy::tconorm_type<Operation<M>>) && std::floating_point<M>
			[[nodiscard]] constexpr static fuzzy::basic_set<V, M, Container, Allocator> apply(fuzzy::basic_set<V, M, Container, Allocator> const& a, fuzzy::basic_set<V, M, Container, Allocator> const& b)
			{
				using set_t = fuzzy::basic_set<V, M, Container, Allocator>;
				using element_t = typename set_t::element_type;
				using op_t = Operation<M>;
				using pair_t = typename set_operation_value_sequence<V, M, Container, Allocator>::value_t;

				set_t result{ b.get_allocator() };
				std::size_t const max_size = std::max(a.size(), b.size());
				std::size_t const half_max_size = max_size / 2u;
				std::size_t const capacity = a.size() + b.size() + half_max_size;
				result.reserve(capacity);

				set_operation_value_sequence<V, M, Container> seq{ a, b };
				for (pair_t pair : seq)
				{
					V v = pair.first.value();
					M m = op_t::apply(pair.first.membership(), pair.second.membership());
					result.insert(element_t{ v, m });
				}
				detail::simplify_impl<V, M, Container>::apply(result); // NOTE: This is not merely a space optimization, it is for correctness with mapping rules.

				return result;
			}
		};

		template <class V, class VF>
		requires ValueFunction<VF, V>
		V values(V a, V b, VF vf)
		{
			return vf(a, b);
		}

		/* Triangular conorm function object.**/
		template <typename M = float>
		requires std::floating_point<M>
		class tconorm_binder
		{
		public:
			using tconorm = tconorm_tag;
			using value_type = M;
			using func_ptr = M(*)(M x, M y);

			tconorm_binder() { func_ = [](M, M) { return std::numeric_limits<M>::quiet_NaN(); }; }
			tconorm_binder(tconorm_binder<M> const&) = delete;
			tconorm_binder(tconorm_binder<M>&&) = delete;
			tconorm_binder<M>& operator=(tconorm_binder<M> const&) = delete;
			tconorm_binder<M>& operator=(tconorm_binder<M>&&) = delete;

			/** binds to a specific tconorm type */
			template <typename T>
			requires tconorm_type<T>
			constexpr void bind(T) noexcept
			{
				func_ = [](M x, M y) -> M { return T::apply(x, y); };
			}

			[[nodiscard]] constexpr M apply(M x, M y) noexcept
			{
				validate_range<M>(x, y);
				return func_(x, y);
			}

		private:
			func_ptr func_ = nullptr;
		};

		/* Triangular conorm function object.**/
		template <class M = float>
		requires std::floating_point<M>
		class tnorm_binder
		{
		public:
			using tnorm = tnorm_tag;
			using func_ptr = M(*)(M x, M y);

			tnorm_binder() { func_ = [](M, M) { return std::numeric_limits<M>::quiet_NaN(); }; }
			tnorm_binder(tnorm_binder<M> const&) = delete;
			tnorm_binder(tnorm_binder<M>&&) = delete;
			tnorm_binder<M>& operator=(tnorm_binder<M> const&) = delete;
			tnorm_binder<M>& operator=(tnorm_binder<M>&&) = delete;

			/** binds to a specific tconorm type */
			template <class T>
			requires tnorm_type<T>
			constexpr void bind(T) noexcept
			{
				func_ = [](M x, M y) -> M { return T::apply(x, y); };
			}

			[[nodiscard]] constexpr M apply(M x, M y) noexcept
			{
				validate_range<M>(x, y);
				return func_(x, y);
			}

		private:
			func_ptr func_;
		};

		template <class V, class M>
		requires fuzzy::numeric<V> && std::floating_point<M>
		struct edge
		{
			basic_element<V, M> v0;
			basic_element<V, M> v1;
		};

		template <class V, class M>
		requires fuzzy::numeric<V> && std::floating_point<M>
		constexpr std::span<fuzzy::basic_element<V, M>> calculate_linear_steps(fuzzy::basic_element<V,M> le, fuzzy::basic_element<V, M> re, std::span<fuzzy::basic_element<V, M>> steps)
		{
			using math::promote;
			M const dy = re.membership() - le.membership();
			M const dx = static_cast<M>(promote(re.value()) - promote(le.value()));
			M const lm = dy / dx;
			M const lb = le.membership() - (lm * static_cast<M>(le.value()));

			M const step_size = dx / static_cast<M>(steps.size() + 1ull);
			M step_x = step_size + static_cast<M>(le.value());
			for (auto itr = begin(steps); itr != end(steps); ++itr, step_x += step_size)
			{
				const M x = fuzzy::math::round<V>(step_x);
				const M m = (lm * x) + lb;
				const V v = static_cast<V>(x);
				*itr = fuzzy::basic_element<V, M>{ v, m };
			}

			return steps;
		};

		template <class Func, class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc> class Container, class Allocator>
		requires fuzzy::numeric<V> && std::floating_point<M>
		[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> linguistic_term_impl(fuzzy::basic_set<V, M, Container, Allocator> const& aset, Func const& func, std::size_t step_count = linguistic_term_default_steps)
		{
			using math::promote;
			using set_type = fuzzy::basic_set<V, M, Container, Allocator>;
			using element_type = typename set_type::element_type;
			set_type result;

			constexpr M min_threshold = static_cast<M>(0.25);
			constexpr M max_threshold = static_cast<M>(0.95);

			// Handle special cases of empty or 1 element.
			if (aset.empty())
			{
				return result;
			}
			if (aset.size() == 1ull)
			{
				element_type e = aset.front();
				e.membership(std::sqrt(e.membership()));
				result.insert(std::move(e));
			}

			std::array<element_type, linguistic_term_max_steps> buffer = 
			{ 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0} 
			};
			auto calc_steps = [&](element_type lhs, element_type rhs) -> std::size_t
			{
				assert(rhs.value() > lhs.value());
				std::size_t const steps = std::min(static_cast<std::size_t>(rhs.value() - lhs.value()) - 1ull, step_count);
				return std::min(steps, buffer.size());
			};

			// Handle the general case.
			auto itr_last = begin(aset);
			assert(itr_last != end(aset));
			for (auto itr = itr_last + 1; itr != end(aset); ++itr_last, ++itr)
			{
				result.insert(element_type{ itr_last->value(), func(itr_last->membership()) });

				M const lm = itr_last->membership();
				M const rm = itr->membership();
				if ((lm > max_threshold && rm < min_threshold) || (lm < min_threshold && rm > max_threshold))
				{
					std::span<element_type> steps = calculate_linear_steps(
						*itr_last,
						*itr,
						std::span<element_type>{ buffer.data(), buffer.data() + calc_steps(*itr_last, *itr) });
					for (auto e : steps)
					{
						result.insert(element_type{ e.value(), func(e.membership()) });
					}
				}
			}
			return result;
		}

	}

	/**
	 * @brief A version of std::set_intersection compatible with fuzzy set theory.
	 * @tparam V The element value type.
	 * @tparam M The element membership type.
	 * @tparam Allocator The allocator type.
	 * @param lhs The left-hand set for the intersection.
	 * @param rhs The right-hand set for the intersection.
	 * @return A set which is the intersection of the two operands.
	*/
	template <template<typename> class Operation, class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
	requires fuzzy::numeric<V> && std::floating_point<M> && tnorm_type<Operation<M>>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> set_intersection(fuzzy::basic_set<V, M, Container, Allocator> const& lhs, fuzzy::basic_set<V, M, Container, Allocator> const& rhs)
	{
		return fuzzy::detail::operation<Operation>::apply(lhs, rhs);
	}

	/**
	 * @brief A version of std::set_union compatible with fuzzy set theory.
	 * @tparam V The element value type.
	 * @tparam M The element membership type.
	 * @tparam Allocator The allocator type.
	 * @param lhs The left-hand set for the union.
	 * @param rhs The right-hand set for the union.
	 * @return A set which is the union of the two operands.
	*/
	template <template <typename> class Operation, class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
	requires fuzzy::numeric<V> && std::floating_point<M> && tconorm_type<Operation<M>>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> set_union(fuzzy::basic_set<V, M, Container, Allocator> const& lhs, fuzzy::basic_set<V, M, Container, Allocator> const& rhs)
	{
		return fuzzy::detail::operation<Operation>::apply(lhs, rhs);
	}

	// Complement function object.
	template <typename M = float>
	requires std::floating_point<M>
	struct complement
	{
		using value_type = M;

		// Complement as 1 - m.
		// @param m Membership in the range [0,1].
		// @result a value in the range [0,1].
		[[nodiscard]] constexpr static M apply(M m) noexcept
		{
			validate_range<M>(m);
			return static_cast<M>(1.0) - m;
		}
	};

	/**
	* Complement of fuzzy set.
	* @param aset The set to complement.
	* @return The complement of the set.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc = std::allocator<T>> class Container>
	requires fuzzy::numeric<V> && std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> set_complement(fuzzy::basic_set<V, M, Container> const& aset)
	{
		using set_type = fuzzy::basic_set<V, M, Container>;
		using element_type = typename set_type::element_type;
		set_type result;

		constexpr V v_min = std::numeric_limits<V>::lowest();
		constexpr V v_max = std::numeric_limits<V>::max();
		constexpr V v_offset = static_cast<V>(1);
		constexpr M m_max = static_cast<M>(1.0);
		constexpr M m_min = static_cast<M>(0.0);
		constexpr complement<M> comp;

		if (aset.empty())
		{
			result.insert(element_type{ v_min, m_max });
			result.insert(element_type{ v_max, m_max });
			return result;
		}

		M const m_front = comp.apply(aset.front().membership());
		if (m_front != m_min && aset.front().value() != v_min)
		{
			V const v_prefix = aset.front().value() - v_offset;
			if (v_prefix != v_min)
				result.insert(element_type{ v_min, m_max });

			if (m_front != m_min)
				result.insert(element_type{ v_prefix, m_max });
		}

		for (auto& element : aset)
		{
			result.insert(fuzzy::basic_element<V, M>{ element.value(), comp.apply(element.membership()) });
		}

		M const m_back = result.back().membership();
		if (m_back != m_min && aset.back().value() != v_max)
		{
			V const v_postfix = aset.back().value() + v_offset;
			if (v_postfix != v_max)
				result.insert(element_type{ v_max, m_max });

			if (m_back != m_min)
				result.insert(element_type{ v_postfix, m_max });
		}

		return result;
	}
}

#endif // FUZZY_ALGORITHM_HPP