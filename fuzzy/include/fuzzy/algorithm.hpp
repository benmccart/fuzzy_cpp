//  Copyright (c) 2025, Ben McCart
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.

#define FUZZY_USE_TLS_DEF_OPERATOR // FIXME: Remove me!

#ifndef FUZZY_ALGORITHM_HPP
#define FUZZY_ALGORITHM_HPP

#include <cmath>
#include <cstdint>
#include <iterator>
#include <limits>
#include <span>
#include <stack>

#include <fuzzy/concepts.hpp>
#include <fuzzy/element.hpp>
#include <fuzzy/math.hpp>
#include <fuzzy/operator.hpp>
#include <fuzzy/set.hpp>
#include <fuzzy/traits.hpp>

namespace fuzzy
{
	constexpr std::size_t linguistic_term_default_steps = 3ull;
	constexpr std::size_t linguistic_term_max_steps = 7ull;

	namespace detail
	{

		template <class V, class M, template <typename T, typename Alloc = std::allocator<T>> class Container>
		class set_operation_value_sequence
		{
		public:
			using set_t = fuzzy::basic_set<V, M, Container>;
			using element_t = typename set_t::element_type;
			using value_t = std::pair<element_t,element_t>;

			class value_step_iterator
			{
			public:
				using iterator_category = std::forward_iterator_tag;
				using value_type = element_t;
				using difference_type = std::ptrdiff_t;
				using pointer = value_type const*;
				using reference = value_type;
				using iter_impl_t = typename set_t::const_iterator;

				value_step_iterator() = delete;

				constexpr explicit value_step_iterator(iter_impl_t itr, set_t const& set) : itr_(itr), set_(&set), value_({ static_cast<V>(0), static_cast<M>(0) })
				{
					if (itr_ != cend(*set_))
						value_ = *itr_;
				}

				constexpr value_step_iterator(value_step_iterator const&) = default;


				constexpr value_step_iterator& operator++()
				{
					++itr_;
					if (itr_ != cend(*set_))
						value_ = *itr_;

					return *this; 
				}

				constexpr value_step_iterator operator++(int)
				{
					value_step_iterator retval = *this;
					++(*this);
					return retval;
				}

				constexpr bool operator!=(value_step_iterator const& o) const    { return !(*this == o);  }
				constexpr bool operator==(value_step_iterator const& o) const    { return itr_ == o.itr_; }

				constexpr reference operator*() const                            { return value_;         }
				constexpr pointer operator->() const                             { return &value_;        }

				void value(V v)
				{
					assert(v > itr_->value());
					auto next = [](iter_impl_t itr) { return ++itr; }(itr_);
					if (next == cend(*set_))
					{
						itr_ = next;
						value_ = element_t{ std::numeric_limits<V>::max(), std::numeric_limits<M>::quiet_NaN() };
					}
					else
					{
						value_ = element_t{ v, set_->membership(v) };
					}
				}

			private:
				iter_impl_t itr_;
				set_t const *set_;
				element_t value_;
			};

			class const_iterator 
			{
			public:
				using iterator_category = std::forward_iterator_tag;
				using value_type = value_t;
				using difference_type = std::ptrdiff_t;
				using pointer = value_t*;
				using reference = value_t;
				using iter_impl_t = typename set_t::const_iterator;
				using segment_t = fuzzy::math::basic_segment<V, M>;

				const_iterator() = delete;

				constexpr explicit const_iterator(iter_impl_t a, set_t const &a_set, iter_impl_t b, set_t const &b_set)
					: a_(a, a_set), a_set_(&a_set), b_(b, b_set), b_set_(&b_set) {}

				constexpr const_iterator(const_iterator const&) = default;

				constexpr const_iterator& operator++()
				{
					auto a_end = value_step_iterator{ cend(*a_set_), *a_set_ };
					auto b_end = value_step_iterator{ cend(*b_set_), *b_set_ };
					if (a_ != a_end && b_ != b_end)
					{
						V av = a_->value();
						V bv = b_->value();
						if (av < bv)
							advance_a();
						else if (bv < av)
							advance_b();
						else { advance_a(); advance_b(); }
					}
					else if (a_ != a_end)
						advance_a();
					else if (b_ != b_end)
						advance_b();

					 return *this; 
				}

				constexpr const_iterator operator++(int)
				{
					const_iterator retval = *this;
					++(*this);
					return retval; 
				}

				constexpr bool operator!=(const_iterator const& o) const { return !(*this == o); }
				constexpr bool operator==(const_iterator const& o) const
				{
					return (a_ == o.a_ && b_ == o.b_);
				}

				constexpr reference operator*() const
				{
					auto a_end = value_step_iterator{ cend(*a_set_), *a_set_ };
					auto b_end = value_step_iterator{ cend(*b_set_), *b_set_ };
					if (a_ != a_end && b_ != b_end)
					{
						V av = a_->value();
						V bv = b_->value();
						if (av < bv)
							return value_t{ *a_, element_t{ av, b_set_->membership(av)} };
						else if (bv < av)
							return value_t{ element_t{ bv, a_set_->membership(bv)}, *b_ };
						else
							return value_t{ *a_, *b_ };
					}
					else if (a_ != a_end)
						return value_t{ *a_, element_t{ a_->value(), b_set_->membership(a_->value())} };
					else if (b_ != b_end)
						return value_t{ element_t{ b_->value(), a_set_->membership(b_->value()) }, * b_ };

					return value_t{ std::numeric_limits<V>::max(), std::numeric_limits<M>::quiet_NaN() };
				}
	
			private:
				constexpr void advance_a()
				{
					auto a_next = [](value_step_iterator itr) { return ++itr; }(a_);
					V const v0 = a_->value();
					V const v1 = std::min(a_next->value(), b_->value());
					segment_t seg_a
					{ 
						*a_,
						element_t{ v1, a_set_->membership(v1) }
					};
					segment_t seg_b
					{
						element_t{ v0, b_set_->membership(v0) },
						element_t{ v1, b_set_->membership(v1) },
					};

					auto rm_current = relative_membership(seg_a.v0, seg_b.v0);
					auto rm_next = relative_membership(seg_a.v1, seg_b.v1);
					if (do_relative_memberships_intersect(rm_current, rm_next))
					{
						element_t intersec = intersection(seg_a, seg_b);
						assert(intersec.membership() == intersec.membership());
						if (intersec.value() == a_->value())
							a_ = a_next;
						else
							a_.value(intersec.value());
					}
					else
					{
						a_ = a_next;
					}
				}
				constexpr void advance_b()
				{
					auto b_next = [](value_step_iterator itr) { return ++itr; }(b_);
					V const v0 = b_->value();
					V const v1 = std::min(b_next->value(), a_->value());
					segment_t seg_a
					{
						element_t{ v0, a_set_->membership(v0) },
						element_t{ v1, a_set_->membership(v1) }
					};
					segment_t seg_b
					{
						*b_,
						element_t{ v1, b_set_->membership(v1) },
					};

					auto rm_current = relative_membership(seg_a.v0, seg_b.v0);
					auto rm_next = relative_membership(seg_a.v1, seg_b.v1);
					if (do_relative_memberships_intersect(rm_current, rm_next))
					{
						element_t intersec = intersection(seg_a, seg_b);
						assert(intersec.membership() == intersec.membership());
						if (intersec.value() == b_->value())
							b_ = b_next;
						else
							b_.value(intersec.value());
					}
					else
					{
						b_ = b_next;
					}
				}
				constexpr void advance_ab()
				{
					auto a_next = [](value_step_iterator itr) { return ++itr; }(a_);
					auto b_next = [](value_step_iterator itr) { return ++itr; }(b_);
					V const v0 = a_->value();
					assert(v0 == b_->value());
					V const v1 = std::min(a_next->value(), b_next->value());
					segment_t seg_a
					{
						*a_,
						element_t{ v1, a_set_->membership(v1) }
					};
					segment_t seg_b
					{
						*b_,
						element_t{ v1, b_set_->membership(v1) },
					};

					auto rm_current = relative_membership(seg_a.v0, seg_b.v0);
					auto rm_next = relative_membership(seg_a.v1, seg_b.v1);
					if (do_relative_memberships_intersect(rm_current, rm_next))
					{
						element_t intersec = intersection(seg_a, seg_b);
						assert(intersec.membership() == intersec.membership());
						if (intersec.value() == a_.value_())
						{
							a_ = a_next;
							b_ = b_next;
						}
						else
						{
							a_.value(intersec.value());
							b_.value(intersec.value());
						}
					}
					else
					{
						a_ = a_next;
						b_ = b_next;
					}
				}

				constexpr static int relative_membership(element_t e0, element_t e1)
				{
					if (e0.membership() < e1.membership())
						return -1;
					else if (e0.membership() > e1.membership())
						return 1;
					else return 0;
				}

				constexpr static bool do_relative_memberships_intersect(int rm0, int rm1)
				{
					int const result = rm0 - rm1;
					return std::abs(result) == 2;
				}

				value_step_iterator a_;
				set_t const *a_set_;
				value_step_iterator b_;
				set_t const *b_set_;
			};
			
			
			set_operation_value_sequence() = delete;
			constexpr set_operation_value_sequence(set_t const& a, set_t const& b) : a_(a), b_(b) {}

			constexpr const_iterator begin() const
			{
				return const_iterator{ fuzzy::cbegin(a_), a_, fuzzy::cbegin(b_), b_};
			}

			constexpr const_iterator end() const
			{
				return const_iterator{ fuzzy::cend(a_), a_, fuzzy::cend(b_), b_ };
			}

		private:

			set_t const& a_;
			set_t const& b_;
		};

		template <class V, class M, template <typename T, typename Alloc> class Container>
		constexpr typename set_operation_value_sequence<V, M, Container>::iterator begin(set_operation_value_sequence<V, M, Container> const& set) { return set.begin(); }

		template <class V, class M, template <typename T, typename Alloc> class Container>
		constexpr typename set_operation_value_sequence<V, M, Container>::iterator end(set_operation_value_sequence<V, M, Container> const& set)   { return set.end();   }

		struct trim
		{
			template <class V, class M, template <typename T, typename Alloc> class Container>
			constexpr static void apply(fuzzy::basic_set<V, M, Container>& v)
			{
				constexpr M zero_m = static_cast<M>(0);
				if (v.size() < 3ull)
					return;

				auto ritr = cend(v) - 1ull;
				auto ritr_next = ritr - 1ull;
				for (; ritr->membership() == zero_m && ritr_next != cbegin(v) && ritr_next->membership() == zero_m; ritr = v.erase(ritr) - 1ull, ritr_next = ritr - 1ull) {}

				auto itr = cbegin(v);
				auto itr_next = itr + 1ull;
				for (; itr->membership() == zero_m && (cend(v) - itr_next) > 1ull && itr_next->membership() == zero_m; itr = v.erase(itr), itr_next = itr + 1ull) {}
			}

			/**
			* @brief Finds the sequence that represents the original sequence but with front and back elements that have zero membership removed.
			* @tparam V The value type.
			* @tparam M The membership type.
			* @tparam Container The underlying storage container type for the set.
			* @param seq The set operation value sequence.
			* @return A pair of iterators pointing to a subset of the original sequence.
			*/
			template <class V, class M, template <typename T, typename Alloc> class Container>
			requires fuzzy::numeric<V> && std::floating_point<M>
			constexpr static auto apply(typename set_operation_value_sequence<V, M, Container>::const_iterator first, typename set_operation_value_sequence<V, M, Container>::const_iterator last)
			{
				using const_iterator = typename set_operation_value_sequence<V, M, Container>::const_iterator;
				std::pair<const_iterator, const_iterator> result{ first, last };

				using element_t = fuzzy::basic_element<V, M>;
				auto non_zero = [](element_t a, element_t b) -> bool { return a.membership() != static_cast<M>(0) && b.membership() != static_cast<M>(0); };
				for (auto itr = first; itr != last; ++itr)
				{
					auto cpair = *itr;
					if (non_zero(cpair.first, cpair.second))
					{
						result.second = itr;
						auto ipair = *result.first;
						if (!non_zero(ipair.first, ipair.second))
							result.first = itr;
					}
				}
				if (result.second != last)
					++result.second;

				return result;
			}
		};

		struct simplify_impl
		{
			template <class V, class M>
			requires fuzzy::numeric<V> && std::floating_point<M>
			constexpr static M slope(fuzzy::basic_element<V, M> p0, fuzzy::basic_element<V, M> p1)
			{
				M dx = static_cast<M>(p1.value()) - static_cast<M>(p0.value());
				M dy = p1.membership() - p0.membership();
				return dy / dx;
			}

			template <class M>
			requires std::floating_point<M>
			constexpr static bool slopes_equivelant(M s0, M s1)
			{
				M diff = static_cast<M>(std::abs(s1 - s0));
				return diff < static_cast<M>(0.000035f);
			}

			/**
			 * @brief The effect is to remove fuzzy values that are co-linear with values before and after.
			 * @tparam M Floating-point type used for membership.
			 * @tparam V Integral type used for value.
			 * @tparam Container The container type used for the set.
			 * @param set The set to simplify in-place.
			*/
			template <class V, class M, template <typename T, typename Alloc> class Container>
			requires fuzzy::numeric<V> &&  std::floating_point<M>
			constexpr static void apply(fuzzy::basic_set<V, M, Container> &set)
			{
				using iterator = typename fuzzy::basic_set<V, M, Container>::iterator;

				if (set.size() == 2u && set.front().membership() == static_cast<M>(0) && set.back().membership() == static_cast<M>(0))
					set.clear(); // The set is indistinguishable from empty if both values are zero.

				if (set.size() < 3u)
					return; // No simplification is possible.

				iterator last = set.end();
				for (iterator prev = set.begin(),itr = prev + 1,next = itr + 1; next != last;)
				{
					M const s0 = slope(*prev, *itr);
					M const s1 = slope(*itr, *next);
					if (slopes_equivelant(s0, s1))
					{
						std::copy(next, last, itr);
						--last;
					}
					else
					{
						++prev;
						++itr;
						++next;
					}
				}
				set.erase(last, set.end());

				if (set.size() == 2u && set.front().membership() == static_cast<M>(0) && set.back().membership() == static_cast<M>(0))
					set.clear(); // The set is indistinguishable from empty if both values are zero.
			}
		};

		template <template <typename> class Operation>
		struct operation
		{
			template <class V, class M, template <typename T, typename Alloc> class Container>
			requires (fuzzy::tnorm_type<Operation<M>> || fuzzy::tconorm_type<Operation<M>>) && std::floating_point<M>
			[[nodiscard]] constexpr static fuzzy::basic_set<V, M, Container> apply(fuzzy::basic_set<V, M, Container> const& a, fuzzy::basic_set<V, M, Container> const& b)
			{
				using set_t = fuzzy::basic_set<V, M, Container>;
				using element_t = typename set_t::element_type;
				using op_t = Operation<M>;
				using pair_t = typename set_operation_value_sequence<V, M, Container>::value_t;

				set_t result{ b.get_allocator() };
				// FIXME: reserve result.
				set_operation_value_sequence<V, M, Container> seq{ a, b };
				for (pair_t pair : seq)
				{
					V v = pair.first.value();
					M m = op_t::apply(pair.first.membership(), pair.second.membership());
					result.insert(element_t{ v, m });
				}
				trim::apply(result);

				return result;
			}
		};

		template <class V, class VF>
		requires ValueFunction<VF, V>
		V values(V a, V b, VF vf)
		{
			return vf(a, b);
		}

		/* Triangular conorm function object.**/
		template <typename M = float>
		requires std::floating_point<M>
		class tconorm_binder
		{
		public:
			using tconorm = tconorm_tag;
			using value_type = M;
			using func_ptr = M(*)(M x, M y);

			tconorm_binder() { func_ = [](M, M) { return std::numeric_limits<M>::quiet_NaN(); }; }
			tconorm_binder(tconorm_binder<M> const&) = delete;
			tconorm_binder(tconorm_binder<M>&&) = delete;
			tconorm_binder<M>& operator=(tconorm_binder<M> const&) = delete;
			tconorm_binder<M>& operator=(tconorm_binder<M>&&) = delete;

			/** binds to a specific tconorm type */
			template <typename T>
			requires tconorm_type<T>
			constexpr void bind(T) noexcept
			{
				func_ = [](M x, M y) -> M { return T::apply(x, y); };
			}

			[[nodiscard]] constexpr M apply(M x, M y) noexcept
			{
				validate_range<M>(x, y);
				return func_(x, y);
			}

		private:
			func_ptr func_ = nullptr;
		};

		/* Triangular conorm function object.**/
		template <class M = float>
		requires std::floating_point<M>
		class tnorm_binder
		{
		public:
			using tnorm = tnorm_tag;
			using func_ptr = M(*)(M x, M y);

			tnorm_binder() { func_ = [](M, M) { return std::numeric_limits<M>::quiet_NaN(); }; }
			tnorm_binder(tnorm_binder<M> const&) = delete;
			tnorm_binder(tnorm_binder<M>&&) = delete;
			tnorm_binder<M>& operator=(tnorm_binder<M> const&) = delete;
			tnorm_binder<M>& operator=(tnorm_binder<M>&&) = delete;

			/** binds to a specific tconorm type */
			template <class T>
			requires tnorm_type<T>
			constexpr void bind(T) noexcept
			{
				func_ = [](M x, M y) -> M { return T::apply(x, y); };
			}

			[[nodiscard]] constexpr M apply(M x, M y) noexcept
			{
				validate_range<M>(x, y);
				return func_(x, y);
			}

		private:
			func_ptr func_;
		};

#ifdef FUZZY_USE_TLS_DEF_OPERATOR
		template <class M>
		requires std::floating_point<M>
		thread_local tconorm_binder<M> *current_tconorm = nullptr;

		template <class M>
		requires std::floating_point<M>
		thread_local tnorm_binder<M> *current_tnorm = nullptr;
#endif

		template <class V, class M>
		requires fuzzy::numeric<V> && std::floating_point<M>
		struct edge
		{
			basic_element<V, M> v0;
			basic_element<V, M> v1;
		};

		template <class V, class M>
		requires fuzzy::numeric<V> && std::floating_point<M>
		constexpr std::span<fuzzy::basic_element<V, M>> calculate_linear_steps(fuzzy::basic_element<V,M> le, fuzzy::basic_element<V, M> re, std::span<fuzzy::basic_element<V, M>> steps)
		{
			using math::promote;
			M const dy = re.membership() - le.membership();
			M const dx = static_cast<M>(promote(re.value()) - promote(le.value()));
			M const lm = dy / dx;
			M const lb = le.membership() - (lm * static_cast<M>(le.value()));

			M const step_size = dx / static_cast<M>(steps.size() + 1ull);
			M step_x = step_size + static_cast<M>(le.value());
			for (auto itr = begin(steps); itr != end(steps); ++itr, step_x += step_size)
			{
				const M x = fuzzy::math::round<V>(step_x);
				const M m = (lm * x) + lb;
				const V v = static_cast<V>(x);
				*itr = fuzzy::basic_element<V, M>{ v, m };
			}

			return steps;
		};

		template <class Func, class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc> class Container>
		requires fuzzy::numeric<V> && std::floating_point<M>
		[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> linguistic_term_impl(fuzzy::basic_set<V, M, Container> const& aset, Func const& func, std::size_t step_count = linguistic_term_default_steps)
		{
			using math::promote;
			using set_type = fuzzy::basic_set<V, M, Container>;
			using element_type = typename set_type::element_type;
			set_type result;

			constexpr M min_threshold = static_cast<M>(0.25);
			constexpr M max_threshold = static_cast<M>(0.95);

			// Handle special cases of empty or 1 element.
			if (aset.empty())
			{
				return result;
			}
			if (aset.size() == 1ull)
			{
				element_type e = aset.front();
				e.membership(std::sqrt(e.membership()));
				result.insert(std::move(e));
			}

			std::array<element_type, linguistic_term_max_steps> buffer = 
			{ 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0} 
			};
			auto calc_steps = [&](element_type lhs, element_type rhs) -> std::size_t
			{
				assert(rhs.value() > lhs.value());
				std::size_t const steps = std::min(static_cast<std::size_t>(rhs.value() - lhs.value()) - 1ull, step_count);
				return std::min(steps, buffer.size());
			};

			// Handle the general case.
			auto itr_last = begin(aset);
			assert(itr_last != end(aset));
			for (auto itr = itr_last + 1; itr != end(aset); ++itr_last, ++itr)
			{
				result.insert(element_type{ itr_last->value(), func(itr_last->membership()) });

				M const lm = itr_last->membership();
				M const rm = itr->membership();
				if ((lm > max_threshold && rm < min_threshold) || (lm < min_threshold && rm > max_threshold))
				{
					std::span<element_type> steps = calculate_linear_steps(
						*itr_last,
						*itr,
						std::span<element_type>{ buffer.data(), buffer.data() + calc_steps(*itr_last, *itr) });
					for (auto e : steps)
					{
						result.insert(element_type{ e.value(), func(e.membership()) });
					}
				}
			}
			return result;
		}

	}


	/**
	* Version of std::set_intersection compatible with fuzzy set theory.
	* @param lhs The left hand side fuzzy set operand.
	* @param rhs The right hand side fuzzy set operand.
	* @return The intersection of the two fuzzy sets.
	*/
	template <class V, class M, template <typename T, typename Alloc> class Container, template<typename> class Operation = fuzzy::minimum>
	requires fuzzy::numeric<V> && std::floating_point<M> && tnorm_type<Operation<M>>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> set_intersection(fuzzy::basic_set<V, M, Container> const& lhs, fuzzy::basic_set<V, M, Container> const& rhs)
	{
		return fuzzy::detail::operation<Operation>::apply(lhs, rhs);
	}

	/**
	* Version of std::set_union compatible with fuzzy set theory.
	* @param lhs The left hand side fuzzy set operand.
	* @param rhs The right hand side fuzzy set operand.
	* @return The union of the two fuzzy sets.
	*/
	template <class V, class M, template <typename T, typename Alloc> class Container, template <typename> class Operation = fuzzy::maximum>
	requires fuzzy::numeric<V> && std::floating_point<M> && tconorm_type<Operation<M>>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> set_union(fuzzy::basic_set<V, M, Container> const& lhs, fuzzy::basic_set<V, M, Container> const& rhs)
	{
		return fuzzy::detail::operation<Operation>::apply(lhs, rhs);
	}

#ifdef FUZZY_USE_TLS_DEF_OPERATOR

	template <class T>
	requires tnorm_type<T> && std::floating_point<typename T::value_type>
	class use_tnorm_t
	{
	public:
		using value_type = typename T::value_type;

		use_tnorm_t() = delete;
		use_tnorm_t(use_tnorm_t<T> const&) = delete;
		use_tnorm_t(use_tnorm_t<T>&&) = delete;
		use_tnorm_t<T>& operator=(use_tnorm_t<T> const&) = delete;
		use_tnorm_t<T>& operator=(use_tnorm_t<T>&&) = delete;

		constexpr use_tnorm_t(T) noexcept
			: previous_(detail::current_tnorm<value_type>)
		{
			current_.bind(T{});
			detail::current_tnorm<value_type> = &current_;
		}

		constexpr ~use_tnorm_t() noexcept
		{
			assert(detail::current_tnorm<value_type> == &current_);
			detail::current_tnorm<value_type> = previous_;
		}

	private:
		detail::tnorm_binder<value_type> current_;
		detail::tnorm_binder<value_type> *previous_;
	};

	template<class T> use_tnorm_t(T) -> use_tnorm_t<T>;
	

	template <class T>
	requires tconorm_type<T>&& std::floating_point<typename T::value_type>
	class use_tconorm_t
	{
	public:
		using value_type = typename T::value_type;

		use_tconorm_t() = delete;
		use_tconorm_t(use_tconorm_t<T> const&) = delete;
		use_tconorm_t(use_tconorm_t<T>&&) = delete;
		use_tconorm_t<T>& operator=(use_tconorm_t<T> const&) = delete;
		use_tconorm_t<T>& operator=(use_tconorm_t<T>&&) = delete;

		constexpr use_tconorm_t(T) noexcept
			: previous_(detail::current_tconorm<value_type>)
		{
			current_.bind(T{});
			detail::current_tconorm<value_type> = &current_;
		}

		constexpr ~use_tconorm_t() noexcept
		{
			assert(detail::current_tconorm<value_type> == &current_);
			detail::current_tconorm<value_type> = previous_;
		}

	private:
		detail::tconorm_binder<value_type> current_;
		detail::tconorm_binder<value_type>* previous_;
	};

	template<class T> use_tconorm_t(T) -> use_tconorm_t<T>;





#endif

	/**
	* Intersects two fuzzy sets.
	* @param aset The lhs set to intersect.
	* @return The intersection of the sets.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc> class Container>
	requires fuzzy::numeric<V> && std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> operator&(fuzzy::basic_set<V, M, Container> const& lhs, fuzzy::basic_set<V, M, Container> const& rhs)
	{
		return set_intersection<V, M, Operation, Container>(lhs, rhs);
	}

	/**
	* Unions two fuzzy sets.
	* @param aset The lhs set to intersect.
	* @return The unions of the sets.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc> class Container>
		requires fuzzy::numeric<V> && std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> operator|(fuzzy::basic_set<V, M, Container> const& lhs, fuzzy::basic_set<V, M, Container> const& rhs)
	{
		return set_union<V, M, Operation, Container>(lhs, rhs);
	}

	/**
	* Complement of fuzzy set.
	* @param aset The set to complement.
	* @return The complement of the set.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc = std::allocator<T>> class Container>
	requires fuzzy::numeric<V> && std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> set_complement(fuzzy::basic_set<V, M, Container> const& aset)
	{
		using set_type = fuzzy::basic_set<V, M, Container>;
		using element_type = typename set_type::element_type;
		set_type result;

		constexpr V v_min = std::numeric_limits<V>::lowest();
		constexpr V v_max = std::numeric_limits<V>::max();
		constexpr V v_offset = static_cast<V>(1);
		constexpr M m_max = static_cast<M>(1.0);
		constexpr M m_min = static_cast<M>(0.0);
		constexpr complement<M> comp;

		if (aset.empty())
		{
			result.insert(element_type{ v_min, m_max });
			result.insert(element_type{ v_max, m_max });
			return result;
		}

		M const m_front = comp.apply(aset.front().membership());
		if (m_front != m_min && aset.front().value() != v_min)
		{
			V const v_prefix = aset.front().value() - v_offset;
			if (v_prefix != v_min)
				result.insert(element_type{ v_min, m_max });

			if (m_front != m_min)
				result.insert(element_type{ v_prefix, m_max });
		}

		for (auto& element : aset)
		{
			result.insert(fuzzy::basic_element<V, M>{ element.value(), comp.apply(element.membership()) });
		}

		M const m_back = result.back().membership();
		if (m_back != m_min && aset.back().value() != v_max)
		{
			V const v_postfix = aset.back().value() + v_offset;
			if (v_postfix != v_max)
				result.insert(element_type{ v_max, m_max });

			if (m_back != m_min)
				result.insert(element_type{ v_postfix, m_max });
		}

		return result;
	}


	/**
	* Fuzzy term 'somewhat' relaxes requirement for the fuzzy set.
	* @param aset The set to relax.
	* @return The relaxed set.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc = std::allocator<T>> class Container>
	requires fuzzy::numeric<V> && std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> somewhat(fuzzy::basic_set<V, M, Container> const& aset, std::size_t steps = linguistic_term_default_steps)
	{
		constexpr auto somewhat_func = [](M m) { return std::sqrt(m); };
		return detail::linguistic_term_impl(aset, somewhat_func, steps);
	}

	/**
	* Fuzzy term 'verry' tightens requirement for the fuzzy set.
	* @param aset The set to tighten.
	* @return The tightened set.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc = std::allocator<T>> class Container>
	requires fuzzy::numeric<V> && std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> very(fuzzy::basic_set<V, M, Container> const& aset, std::size_t steps = linguistic_term_default_steps)
	{
		constexpr auto very_func = [](M m) { return m * m; };
		return detail::linguistic_term_impl(aset, very_func, steps);
	}

	/**
	* Complement of fuzzy set.
	* @param aset The set to complement.
	* @return The complement of the set.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, template <typename T, typename Alloc = std::allocator<T>> class Container>
	requires fuzzy::numeric<V> && std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> operator~(fuzzy::basic_set<V, M, Container> const& aset)
	{
		return set_complement<V,M,Operation, Container>(aset);
	}


}

#endif // FUZZY_ALGORITHM_HPP