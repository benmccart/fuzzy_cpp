//  Copyright (c) 2026, Ben McCart
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.

#ifndef FUZZY_ALGORITHM_HPP
#define FUZZY_ALGORITHM_HPP

#include <cmath>
#include <cstdint>
#include <iterator>
#include <limits>
#include <memory>
#include <memory_resource>
#include <optional>
#include <span>
#include <stack>

#include <fuzzy/concepts.hpp>
#include <fuzzy/element.hpp>
#include <fuzzy/math.hpp>
#include <fuzzy/norm_conorm.hpp>
#include <fuzzy/set.hpp>
#include <fuzzy/traits.hpp>

namespace fuzzy
{
	constexpr std::size_t linguistic_term_default_steps = 3ull;
	constexpr std::size_t linguistic_term_max_steps = 7ull;

	namespace detail
	{

		/**
		 * @brief Manages complex state of iterating two sets.
		 * @tparam V The set element value type.
		 * @tparam M The set element membership type.
		 * @tparam Allocator The allocator type.
		*/
		template <class V, class M, template <typename T, typename Alloc = std::allocator<T>> class Container, class Allocator = std::allocator<fuzzy::basic_element<V,M>>>
		class set_operation_value_sequence
		{
		public:
			using set_t = fuzzy::basic_set<V, M, Container, Allocator>;
			using element_t = typename set_t::element_type;
			using value_t = std::pair<element_t,element_t>;

			/**
			 * @brief Iterator type that handles all the gory details of iterating over the two sets so that vertices for each are iterated in order
			 *        with the membership of each set supplied for each value.  Includes all intersections between the two sets in order.
			*/
			class const_iterator
			{
			public:
				using iterator_category = std::forward_iterator_tag;
				using value_type = value_t;
				using difference_type = std::ptrdiff_t;
				using pointer = value_t*;
				using reference = value_t;
				using iter_impl_t = typename set_t::const_iterator;
				using element_t = basic_element<V, M>;
				using segment_t = fuzzy::math::basic_segment<V, M>;
				using optional_element_t = std::optional<element_t>;

				const_iterator() = delete;

				constexpr explicit const_iterator(iter_impl_t a, set_t const& a_set, iter_impl_t b, set_t const& b_set)
					: a_(a)
					, a_end_(a_set.cend())
					, a_set_(&a_set)
					, b_(b)
					, b_end_(b_set.cend())
					, b_set_(&b_set)
					, last_(find_first(a, a_set.cend(), b, b_set.cend()))
					, a_value_(bad_value())
					, b_value_(bad_value())
				{
					if (a_ != a_end_ && (b_ == b_end_ || a_->value() <= b_->value()))
						set_values(a_, b_end_);
					if (b_ != b_end_ && (a_ == a_end_ || a_->value() >= b_->value()))
						set_values(a_end_, b_);

					if (!((a_value_ != bad_value() && b_value_ != bad_value()) || (a_ == a_end_ && b_ == b_end_)))
					{
						[[maybe_unused]] bool break_here = true;
					}
					assert((a_value_ != bad_value() && b_value_ != bad_value()) || (a_ == a_end_ && b_ == b_end_));
				}

				constexpr const_iterator(const_iterator const&) = default;

				constexpr const_iterator& operator++()
				{
					advance adv = determin_advance();
					switch (adv)
					{
						case advance::to_a: advance_to_a(); break;
						case advance::to_b: advance_to_b(); break;
						case advance::a_to_next:  advance_a_to_next(); break;
						case advance::b_to_next:  advance_b_to_next(); break;
						case advance::a_and_b_to_next: advance_a_and_b_to_next(); break;
						case advance::a_to_end: advance_a_to_end(); break;
						case advance::b_to_end: advance_b_to_end(); break;
						case advance::a_and_b_to_end: advance_a_and_b_to_end(); break;
						default: assert(!"invalid advance instruction");
					}

					return *this; 
				}

				constexpr const_iterator operator++(int)
				{
					const_iterator retval = *this;
					++(*this);
					return retval; 
				}

				constexpr bool operator!=(const_iterator const& o) const { return !(*this == o); }
				constexpr bool operator==(const_iterator const& o) const
				{
					return (a_ == o.a_ && b_ == o.b_);
				}

				constexpr reference operator*()
				{
					return dref_impl();
				}

			private:

				/**
				 * @brief The next advance operation.
				*/
				enum class advance
				{
					to_a,
					to_b,
					a_to_end,
					b_to_end,
					a_and_b_to_end,
					a_to_next,
					b_to_next,
					a_and_b_to_next
				};

				/**
				 * @brief Identification tag for iterator.
				*/
				enum class iterator_tag
				{
					a_next = 1,
					b_next,
					a,
					b,
				};

				static constexpr element_t bad_value() noexcept
				{
					element_t bad{ std::numeric_limits<V>::max(), static_cast<M>(0) };
					bad.membership(-1);
					return bad;
				}

				static constexpr advance tag_to_end(iterator_tag tag) noexcept
				{
					assert(tag == iterator_tag::a || tag == iterator_tag::b);
					return (tag == iterator_tag::a) ? advance::a_to_end : advance::b_to_end;
				}

				static constexpr advance tag_to_advance(iterator_tag tag) noexcept
				{
					switch (tag)
					{
						case iterator_tag::a: return advance::to_a;
						case iterator_tag::a_next: return advance::a_to_next;
						case iterator_tag::b: return advance::to_b;
						case iterator_tag::b_next: return advance::b_to_next;
					}

					assert(!"invalid enumerated value");
					return advance::a_and_b_to_end;
				}

				static constexpr advance tag_to_advance(iterator_tag n, iterator_tag an) noexcept
				{
					if ((n == iterator_tag::a_next && an == iterator_tag::b_next) ||
						(n == iterator_tag::b_next && an == iterator_tag::a_next))
					{
						return advance::a_and_b_to_next;
					}

					return tag_to_advance(n);
				}

				struct advance_data
				{
					iter_impl_t itr;
					iterator_tag tag;
				};

				constexpr reference dref_impl() const
				{
					if (intersection_)
					{
						return value_t{ *intersection_, *intersection_ };
					}
					else
					{
						assert(a_value_.value() == b_value_.value());
						return value_t{ a_value_, b_value_ };
					}
				}

				constexpr static void push_back(std::array<advance_data, 4>& data, std::size_t& data_size, advance_data&& adv)
				{
					data.at(data_size) = std::move(adv);
					++data_size;
				}

				constexpr advance determin_advance() const
				{
					assert(a_ != a_end_ || b_ != b_end_);

					// Add and sort relevant data (NOTE: Replace this with pmr::monotonic_buffer_resource when migrating to C++26)
					std::array<advance_data, 4> data_buffer;
					std::size_t data_size = 0u;

					iter_impl_t const a_next = (a_ != a_end_) ? (a_ + 1) : a_end_;
					iter_impl_t const b_next = (b_ != b_end_) ? (b_ + 1) : b_end_;
					if (a_ != a_end_)
						push_back(data_buffer, data_size, advance_data{ a_, iterator_tag::a });
					if (a_next != a_end_)
						push_back(data_buffer, data_size, advance_data{ a_next, iterator_tag::a_next });
					if (b_ != b_end_)
						push_back(data_buffer, data_size, advance_data{ b_, iterator_tag::b });
					if (b_next != b_end_)
						push_back(data_buffer, data_size, advance_data{ b_next, iterator_tag::b_next });

					// Handle special case where we are completing a single side.
					std::span<advance_data> data{ data_buffer.data(), data_size };
					assert(!data.empty());
					if (data.size() == 1u)
						return tag_to_end(data.front().tag);

					// Find the first item that is greater than 'last'
					std::sort(data.begin(), data.end(), [](advance_data const& lhs, advance_data const& rhs) -> bool
					{
						if (lhs.itr->value() == rhs.itr->value())
							return lhs.tag < rhs.tag;

						return lhs.itr->value() < rhs.itr->value();
					});
					auto const next = std::find_if(data.begin(), data.end(), [&](advance_data const item) -> bool
					{
						return item.itr->value() > last_->value();
					});

					// Handle special case where we are at the end.
					if (next == data.end())
					{
						assert((next - 1)->itr->value() == last_->value());
						return advance::a_and_b_to_end;
					}

					assert(next != data.begin());
					assert((next-1)->itr->value() == last_->value());
					assert(next->itr->value() > last_->value());

					// Check for the simple case where there is only one matching value.
					auto after_next = (next+1);
					if (after_next == data.end())
						return tag_to_advance(next->tag);

					// Check for the next simplest case where the next two values don't match.
					if (next->itr->value() != after_next->itr->value())
						return tag_to_advance(next->tag);

					// Handle the complex case where values match and we need to see if they are the same category.
					return tag_to_advance(next->tag, after_next->tag);
				}

				constexpr void set_values(iter_impl_t a, iter_impl_t b)
				{
					if (a != a_end_)
					{
						a_ = a;
						last_ = a;
						a_value_ = element_t{ *a };
					}
					else
					{
						assert(b != b_end_);
						a_value_ = element_t{ b->value(), a_set_->membership(b->value()) };
					}

					if (b != b_end_)
					{
						b_ = b;
						last_ = b;
						b_value_ = element_t{ *b };
					}
					else
					{
						assert(a != a_end_);
						b_value_ = element_t{ a->value(), b_set_->membership(a->value()) };
					}
				}

				constexpr iter_impl_t find_first(iter_impl_t const &a, iter_impl_t const &a_end, iter_impl_t const &b, iter_impl_t const &b_end)
				{
					if (a == a_end && b == b_end)
						return a;
					if (a == a_end)
						return b;
					if (b == b_end)
						return a;

					return (a->value() < b->value()) ? a : b;
				}

				constexpr void advance_a_to_end()
				{
					a_ = a_end_;
				}

				constexpr void advance_b_to_end()
				{
					b_ = b_end_;
				}

				constexpr void advance_a_and_b_to_end()
				{
					advance_a_to_end();
					advance_b_to_end();
				}

				constexpr void advance_to_a()
				{
					set_values(a_, b_end_);
				}

				constexpr void advance_to_b()
				{
					set_values(a_end_, b_);
				}

				constexpr void advance_a_to_next()
				{
					assert(a_ != a_end_);
					iter_impl_t const a_next = a_ + 1;
					iter_impl_t const b_next = (b_ == b_end_) ? b_ : b_ + 1;
					assert(a_next != a_end_);

					if (b_next == b_end_)
					{
						intersection_.reset();
						set_values(a_next, b_end_);
						return; // Completing 'a'.
					}

					if (intersection_)
					{
						intersection_.reset();
						set_values(a_next, b_end_);
						return; // Advance to next 'a' segment.
					}

					// Check for intersection on current 'a' segment.
					segment_t seg_a{ *a_, *a_next };
					segment_t seg_b{ *b_, *b_next };
					intersection_ = intersection(seg_a, seg_b);
					if (!intersection_)
					{
						// No intersection, advance to next 'a' segment.
						set_values(a_next, b_end_);
					}
				}

				constexpr void advance_b_to_next()
				{
					assert(b_ != b_end_);
					iter_impl_t const a_next = (a_ == a_end_) ? a_ : a_ + 1;
					iter_impl_t const b_next = b_ + 1;
					assert(b_next != b_end_);

					if (a_next == a_end_)
					{
						intersection_.reset();
						set_values(a_end_, b_next);
						return; // Completing 'b'
					}

					if (intersection_)
					{
						intersection_.reset();
						set_values(a_end_, b_next);
						return; // Advance to next 'b' segment.
					}

					// Check for intersection on current 'b' segment.
					segment_t seg_a{ *a_, *a_next };
					segment_t seg_b{ *b_, *b_next };
					intersection_ = intersection(seg_a, seg_b);
					if (!intersection_)
					{
						// No intersection, advance to next 'b' segment.
						set_values(a_end_, b_next);
					}
				}

				constexpr void advance_a_and_b_to_next()
				{
					assert(a_ != a_end_);
					assert(b_ != b_end_);
					iter_impl_t const a_next = a_ + 1;
					iter_impl_t const b_next = b_ + 1;
					assert(a_next != a_end_);
					assert(b_next != b_end_);

					if (intersection_)
					{
						intersection_.reset();
						set_values(a_next, b_next);
						assert(a_->value() == b_->value());
						return; // Advance to next 'b' segment.
					}

					// Check for intersection on current 'b' segment.
					segment_t seg_a{ *a_, *a_next };
					segment_t seg_b{ *b_, *b_next };
					intersection_ = intersection(seg_a, seg_b);
					if (!intersection_)
					{
						// No intersection, advance to next 'b' segment.
						set_values(a_next, b_next);
						assert(a_->value() == b_->value());
					}
				}

				iter_impl_t a_;
				iter_impl_t const a_end_;
				set_t const *a_set_;
				iter_impl_t b_;
				iter_impl_t const b_end_;
				set_t const *b_set_;
				optional_element_t intersection_;
				iter_impl_t last_;
				element_t a_value_;
				element_t b_value_;
			};
			
			
			set_operation_value_sequence() = delete;
			constexpr set_operation_value_sequence(set_t const& a, set_t const& b) : a_(a), b_(b) {}

			constexpr const_iterator begin() const
			{
				return const_iterator{ fuzzy::cbegin(a_), a_, fuzzy::cbegin(b_), b_};
			}

			constexpr const_iterator end() const
			{
				return const_iterator{ fuzzy::cend(a_), a_, fuzzy::cend(b_), b_ };
			}

		private:

			set_t const& a_;
			set_t const& b_;
		};

		template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
		constexpr typename set_operation_value_sequence<V, M, Container>::iterator begin(set_operation_value_sequence<V, M, Container, Allocator> const& set) { return set.begin(); }

		template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
		constexpr typename set_operation_value_sequence<V, M, Container>::iterator end(set_operation_value_sequence<V, M, Container, Allocator> const& set)   { return set.end();   }

		/**
		 * @brief A utility class for simplifying a fuzzy set.
		 * @tparam M The set element membership type.
		 * @tparam V The set element value type.
		 * @tparam Container The container type used for the set.
		*/
		template <class V, class M, template <typename T, typename Alloc> class Container>
		requires fuzzy::numeric<V> && std::floating_point<M>
		class simplify_impl
		{
		private:
			using set_t = basic_set<V, M, Container>;
			using element_t = basic_element<V, M>;
			using iterator = typename set_t::iterator;

			struct state_t
			{
				iterator dst;
				iterator prev;
				iterator itr;
				iterator next;
				iterator last;
				iterator end;
			};

			constexpr static iterator find_first(set_t &set)
			{
				constexpr M zero = static_cast<M>(0);
				iterator itr = std::find_if(set.begin(), set.end(), [](element_t const& e) -> bool { return e.membership() != zero; });
				if (itr != set.begin())
					--itr;

				return itr;
			}

			constexpr static iterator find_last(set_t& set)
			{
				constexpr M zero = static_cast<M>(0);
				auto itr = std::find_if(set.rbegin(), set.rend(), [](element_t const& e) -> bool { return e.membership() != zero; });
				if (itr != set.rbegin())
					--itr;

				return itr.base();
			}

			constexpr static bool check_range(set_t& set, iterator first, iterator last)
			{
				if (last < first)
				{
					set.clear();
					return false;
				}

				if (last - first < 3)
				{
					auto itr = last;
					if (first != set.begin())
					{
						std::copy(first, last, set.begin());
						itr = set.begin() + (last - first);
					}
					set.erase(itr, set.end());
					return false;
				}

				return true;
			}

			constexpr static M slope(fuzzy::basic_element<V, M> p0, fuzzy::basic_element<V, M> p1)
			{
				M const dx = static_cast<M>(p1.value() - p0.value());
				M const inv_denom = static_cast<M>(1) / dx;
				M const dy = p1.membership() - p0.membership();
				return dy * inv_denom;
			}

			constexpr static bool erase_predicate(iterator const& prev, iterator const& itr, iterator const& next) noexcept
			{
				M const s0 = slope(*prev, *next);
				M const s1 = [&]()
				{
					V const dprev = itr->value() - prev->value();
					V const dnext = next->value() - itr->value();
					if (dnext > dprev)
						return slope(*itr, *next);
					else
						return slope(*prev, *itr);
				}();
				constexpr M slope_multiplier = static_cast<M>(5);
				constexpr M sro = slope_multiplier * fuzzy::math::detail::round_off<M>();
				if (fuzzy::math::equivelant(s0, s1, sro))
				{
					return true;
				}

				return false;
			}

			constexpr static void finish_prev(state_t& state)
			{
				assert(state.next == state.last);
				assert(state.itr + 1 == state.last);
				for (;state.prev != state.last;)
				{
					if (state.dst != state.end && state.dst < state.prev)
					{
						assert(state.dst < state.prev);
						*state.dst = std::move(*state.prev);
						++state.dst;
					}

					if (state.itr != state.last)
					{
						state.prev = state.itr;
						state.itr = state.next;
						assert(state.itr == state.last);
					}
					else
					{
						++state.prev;
					}
				}
			}

			constexpr static void advance_prev(state_t& state)
			{
				if (state.dst != state.end && state.dst < state.prev)
				{
					*state.dst = std::move(*state.prev);
					++state.dst;
				}

				state.prev = state.itr;
				state.itr = state.next;
				assert(state.next < state.last);
				++state.next;
				if (state.next == state.last)
					finish_prev(state);
			}

			constexpr static void advance_itr(state_t& state)
			{
				assert(state.itr < state.next && state.next < state.last);
				if (state.dst == state.end)
					state.dst = state.itr;

				++state.itr;
				++state.next;
				if (state.next == state.last)
					finish_prev(state);
			}

		public:

			/**
			 * @brief The effect is to remove fuzzy values that are co-linear with values before and after.
			 *        Value pairs that are to close (floating point) are averaged.
			 * @param set The set to simplify in-place.
			*/
			constexpr static void apply(set_t& set)
			{
				// Check sizes and initial state.
				constexpr M zero = static_cast<M>(0);
				if (set.size() == 2u && set.front().membership() == zero && set.back().membership() == zero)
					set.clear(); // The set is indistinguishable from empty if both values are zero.

				if (set.size() < 3u)
					return; // No simplification is possible.

				iterator first = find_first(set);
				iterator last = find_last(set);
				if (!check_range(set, first, last))
					return;

				iterator const beg = set.begin();
				iterator const end = set.end();
				state_t state
				{
					.dst = (first == beg) ? end : beg,
					.prev = first,
					.itr = first + 1,
					.next = first + 2,
					.last = last,
					.end = end
				};

				for (; state.prev != state.last;)
				{
					assert(state.prev < state.itr && state.itr + 1 == state.next && state.next != state.last);
					if (erase_predicate(state.prev, state.itr, state.next))
						advance_itr(state);
					else
						advance_prev(state);
				}

				assert(state.prev == state.last && state.itr == state.last && state.next == state.last);
				if (state.dst != end)
					set.erase(state.dst, end);
			}
		};

		/**
		 * @brief Implements a binary operation applied to each member of a pair of sets.
		 * @tparam Operation The binary operation type to perform on the elements of the sets.
		*/
		template <template <typename> class Operation>
		struct operation
		{
			/**
			 * @brief Applies the binary operation to the elements of the two sets.
			 * @tparam V The set element value type.
			 * @tparam M The set element membership type.
			 * @tparam Allocator The element allocator type used by the sets.
			 * @param a The first operand set.
			 * @param b The second operand set.
			 * @return A new set that is the result of the operation.
			*/
			template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
			requires (fuzzy::tnorm_type<Operation<M>> || fuzzy::tconorm_type<Operation<M>>) && std::floating_point<M>
			[[nodiscard]] constexpr static fuzzy::basic_set<V, M, Container, Allocator> apply(fuzzy::basic_set<V, M, Container, Allocator> const& a, fuzzy::basic_set<V, M, Container, Allocator> const& b)
			{
				using set_t = fuzzy::basic_set<V, M, Container, Allocator>;
				using element_t = typename set_t::element_type;
				using op_t = Operation<M>;
				using pair_t = typename set_operation_value_sequence<V, M, Container, Allocator>::value_t;

				set_t result{ b.get_allocator() };
				std::size_t const max_size = std::max(a.size(), b.size());
				std::size_t const half_max_size = max_size / 2u;
				std::size_t const capacity = a.size() + b.size() + half_max_size;
				result.reserve(capacity);

				set_operation_value_sequence<V, M, Container> seq{ a, b };
				for (pair_t pair : seq)
				{
					V v = pair.first.value();
					M m = op_t::apply(pair.first.membership(), pair.second.membership());
					result.insert(element_t{ v, m });
				}
				detail::simplify_impl<V, M, Container>::apply(result); // NOTE: This is not merely a space optimization, it is for correctness with mapping rules.

				return result;
			}
		};

		
		/**
		 * @brief A helper function for the linguistic_term_impl.
		 * @tparam V The set element value type.
		 * @tparam M The set element memberhsip type.
		 * @param le left-element.
		 * @param re right-element.
		 * @param steps A span of the steps to apply over.
		 * @return A modified span of steps to apply over.
		*/
		template <class V, class M>
		requires fuzzy::numeric<V> && std::floating_point<M>
		constexpr std::span<fuzzy::basic_element<V, M>> calculate_linear_steps(fuzzy::basic_element<V,M> le, fuzzy::basic_element<V, M> re, std::span<fuzzy::basic_element<V, M>> steps)
		{
			using math::promote;
			M const dy = re.membership() - le.membership();
			M const dx = static_cast<M>(promote(re.value()) - promote(le.value()));
			M const lm = dy / dx;
			M const lb = le.membership() - (lm * static_cast<M>(le.value()));

			M const step_size = dx / static_cast<M>(steps.size() + 1ull);
			M step_x = step_size + static_cast<M>(le.value());
			for (auto itr = begin(steps); itr != end(steps); ++itr, step_x += step_size)
			{
				const M x = fuzzy::math::round<V>(step_x);
				const M m = (lm * x) + lb;
				const V v = static_cast<V>(x);
				*itr = fuzzy::basic_element<V, M>{ v, m };
			}

			return steps;
		};

		/**
		 * @brief Applies a linguistic term to set.
		 * @tparam Func The linguistic term function.
	 	 * @tparam V The set element value type.
		 * @tparam M The set element memberhsip type.
		 * @tparam Allocator The allocator type.
		 * @param aset The set to apply the linguistic term to.
		 * @param func The linguistic term function.
		 * @param step_count The number of steps to inject on shoulder areas of the 'aset'.
		 * @return A copy of 'aset' with the linguistic term applied.
		*/
		template <class Func, class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
		requires fuzzy::numeric<V> && std::floating_point<M>
		[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> linguistic_term_impl(fuzzy::basic_set<V, M, Container, Allocator> const& aset, Func const& func, std::size_t step_count = linguistic_term_default_steps)
		{
			using math::promote;
			using set_type = fuzzy::basic_set<V, M, Container, Allocator>;
			using element_type = typename set_type::element_type;
			set_type result;

			constexpr M min_threshold = static_cast<M>(0.25);
			constexpr M max_threshold = static_cast<M>(0.95);

			// Handle special cases of empty or 1 element.
			if (aset.empty())
			{
				return result;
			}
			if (aset.size() == 1ull)
			{
				element_type e = aset.front();
				e.membership(std::sqrt(e.membership()));
				result.insert(std::move(e));
			}

			std::array<element_type, linguistic_term_max_steps> buffer = 
			{ 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0} 
			};
			auto calc_steps = [&](element_type lhs, element_type rhs) -> std::size_t
			{
				assert(rhs.value() > lhs.value());
				std::size_t const steps = std::min(static_cast<std::size_t>(rhs.value() - lhs.value()) - 1ull, step_count);
				return std::min(steps, buffer.size());
			};

			// Handle the general case.
			auto itr_last = begin(aset);
			assert(itr_last != end(aset));
			for (auto itr = itr_last + 1; itr != end(aset); ++itr_last, ++itr)
			{
				result.insert(element_type{ itr_last->value(), func(itr_last->membership()) });

				M const lm = itr_last->membership();
				M const rm = itr->membership();
				if ((lm > max_threshold && rm < min_threshold) || (lm < min_threshold && rm > max_threshold))
				{
					std::span<element_type> steps = calculate_linear_steps(
						*itr_last,
						*itr,
						std::span<element_type>{ buffer.data(), buffer.data() + calc_steps(*itr_last, *itr) });
					for (auto e : steps)
					{
						result.insert(element_type{ e.value(), func(e.membership()) });
					}
				}
			}
			return result;
		}

	}

	/**
	 * @brief A version of std::set_intersection compatible with fuzzy set theory.
	 * @tparam V The set element value type.
	 * @tparam M The set element membership type.
	 * @tparam Allocator The allocator type.
	 * @param lhs The left-hand set for the intersection.
	 * @param rhs The right-hand set for the intersection.
	 * @return A set which is the intersection of the two operands.
	*/
	template <template<typename> class Operation, class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
	requires fuzzy::numeric<V> && std::floating_point<M> && tnorm_type<Operation<M>>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> set_intersection(fuzzy::basic_set<V, M, Container, Allocator> const& lhs, fuzzy::basic_set<V, M, Container, Allocator> const& rhs)
	{
		return fuzzy::detail::operation<Operation>::apply(lhs, rhs);
	}

	/**
	 * @brief A version of std::set_union compatible with fuzzy set theory.
	 * @tparam V The set element value type.
	 * @tparam M The set element membership type.
	 * @tparam Allocator The allocator type.
	 * @param lhs The left-hand set for the union.
	 * @param rhs The right-hand set for the union.
	 * @return A set which is the union of the two operands.
	*/
	template <template <typename> class Operation, class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
	requires fuzzy::numeric<V> && std::floating_point<M> && tconorm_type<Operation<M>>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container, Allocator> set_union(fuzzy::basic_set<V, M, Container, Allocator> const& lhs, fuzzy::basic_set<V, M, Container, Allocator> const& rhs)
	{
		return fuzzy::detail::operation<Operation>::apply(lhs, rhs);
	}

	/**
	 * @brief Complement function object.
	 * @tparam M 
	*/
	template <typename M = float>
	requires std::floating_point<M>
	struct complement
	{
		using value_type = M;

		// Complement as 1 - m.
		// @param m Membership in the range [0,1].
		// @result a value in the range [0,1].
		[[nodiscard]] constexpr static M apply(M m) noexcept
		{
			validate_range<M>(m);
			return static_cast<M>(1.0) - m;
		}
	};

	/**
	 * @brief Complement of fuzzy set.
	 * @tparam V The set element value type.
	 * @tparam M The set element membership type.
	 * @param aset The set to form the complement of.
	 * @return The complement of 'aset'.
	*/
	template <class V, class M, template <typename T, typename Alloc = std::allocator<T>> class Container>
	requires fuzzy::numeric<V> && std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> set_complement(fuzzy::basic_set<V, M, Container> const& aset)
	{
		using set_type = fuzzy::basic_set<V, M, Container>;
		using element_type = typename set_type::element_type;
		set_type result;

		constexpr V v_min = std::numeric_limits<V>::lowest();
		constexpr V v_max = std::numeric_limits<V>::max();
		constexpr V v_offset = static_cast<V>(1);
		constexpr M m_max = static_cast<M>(1.0);
		constexpr M m_min = static_cast<M>(0.0);
		constexpr complement<M> comp;

		if (aset.empty())
		{
			result.insert(element_type{ v_min, m_max });
			result.insert(element_type{ v_max, m_max });
			return result;
		}

		M const m_front = comp.apply(aset.front().membership());
		if (m_front != m_min && aset.front().value() != v_min)
		{
			V const v_prefix = aset.front().value() - v_offset;
			if (v_prefix != v_min)
				result.insert(element_type{ v_min, m_max });

			if (m_front != m_min)
				result.insert(element_type{ v_prefix, m_max });
		}

		for (auto& element : aset)
		{
			result.insert(fuzzy::basic_element<V, M>{ element.value(), comp.apply(element.membership()) });
		}

		M const m_back = result.back().membership();
		if (m_back != m_min && aset.back().value() != v_max)
		{
			V const v_postfix = aset.back().value() + v_offset;
			if (v_postfix != v_max)
				result.insert(element_type{ v_max, m_max });

			if (m_back != m_min)
				result.insert(element_type{ v_postfix, m_max });
		}

		return result;
	}
}

#endif // FUZZY_ALGORITHM_HPP