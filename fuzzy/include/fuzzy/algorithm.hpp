//  Copyright (c) 2022, Ben McCart
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.

#define FUZZY_USE_TLS_DEF_OPERATOR // FIXME: Remove me!

#ifndef FUZZY_ALGORITHM_HPP
#define FUZZY_ALGORITHM_HPP

#include <cmath>
#include <concepts>
#include <cstdint>
#include <iterator>
#include <limits>
#include <span>
#include <stack>

#include <fuzzy/element.hpp>
#include <fuzzy/math.hpp>
#include <fuzzy/operator.hpp>
#include <fuzzy/set.hpp>
#include <fuzzy/traits.hpp>

namespace fuzzy
{
	constexpr std::size_t linguistic_term_default_steps = 3ull;
	constexpr std::size_t linguistic_term_max_steps = 7ull;

	namespace detail
	{

		struct trim
		{
			template <class V, class M, class Container>
			constexpr static void apply(fuzzy::basic_set<V, M, Container>& v)
			{
				constexpr M zero_m = static_cast<M>(0);
				if (v.size() < 3ull)
					return;

				auto ritr = cend(v) - 1ull;
				auto ritr_next = ritr - 1ull;
				for (; ritr->membership() == zero_m && ritr_next != cbegin(v) && ritr_next->membership() == zero_m; ritr = v.erase(ritr) - 1ull, ritr_next = ritr - 1ull) {}

				auto itr = cbegin(v);
				auto itr_next = itr + 1ull;
				for (; itr->membership() == zero_m && (cend(v) - itr_next) > 1ull && itr_next->membership() == zero_m; itr = v.erase(itr), itr_next = itr + 1ull) {}
			}
		};

		template <class V, class M, class Container>
		class set_operation_value_sequence
		{
		public:
			using set_t = fuzzy::basic_set<V, M, Container>;
			using element_t = typename set_t::element_type;
			using value_t = std::pair<element_t, element_t>;

			class iterator 
			{
			public:
				using iterator_category = std::forward_iterator_tag;
				using value_type = value_t;
				using difference_type = std::ptrdiff_t;
				using pointer = value_t*;
				using reference = value_t;
				using iter_impl_t = typename set_t::const_iterator;

				iterator() = delete;

				constexpr explicit iterator(iter_impl_t a, set_t const &a_set, iter_impl_t b, set_t const &b_set)
					: a_(a), a_set_(&a_set), b_(b), b_set_(&b_set) {}

				constexpr iterator& operator++()
				{
					auto a_end = cend(*a_set_);
					auto b_end = cend(*b_set_);
					if (a_ != a_end && b_ != b_end)
					{
						V av = a_->value();
						V bv = b_->value();
						if (av < bv)
							++a_;
						else if (bv < av)
							++b_;
						else { ++a_; ++b_; }
					}
					else if (a_ != a_end)
						++a_;
					else if (b_ != b_end)
						++b_;

					 return *this; 
				}

				constexpr iterator operator++(int)
				{
					iterator retval = *this;
					++(*this);
					return retval; 
				}

				constexpr bool operator!=(iterator const& o) const { return !(*this == o); }
				constexpr bool operator==(iterator const& o) const
				{
					return (a_ == o.a_ && b_ == o.b_);
				}

				constexpr reference operator*() const
				{
					auto a_end = cend(*a_set_);
					auto b_end = cend(*b_set_);
					if (a_ != a_end && b_ != b_end)
					{
						V av = a_->value();
						V bv = b_->value();
						if (av < bv)
							return value_t{ *a_, element_t{ av, b_set_->membership(av)} };
						else if (bv < av)
							return value_t{ element_t{ bv, a_set_->membership(bv)}, *b_ };
						else
							return value_t{ *a_, *b_ };
					}
					else if (a_ != a_end)
						return value_t{ *a_, element_t{ a_->value(), b_set_->membership(a_->value())} };
					else if (b_ != b_end)
						return value_t{ element_t{ b_->value(), a_set_->membership(b_->value()) }, * b_ };

					return value_t{ std::numeric_limits<V>::max(), std::numeric_limits<M>::quiet_NaN() };
				}
				
				constexpr pointer operator->() const { return this; }

			private:
				iter_impl_t a_;
				set_t const *a_set_;
				iter_impl_t b_;
				set_t const *b_set_;
			};
			
			
			set_operation_value_sequence() = delete;
			constexpr set_operation_value_sequence(set_t const& a, set_t const& b) : a_(a), b_(b) {}

			constexpr iterator begin() const
			{
				return iterator{ fuzzy::cbegin(a_), a_, fuzzy::cbegin(b_), b_};
			}

			constexpr iterator end() const
			{
				return iterator{ fuzzy::cend(a_), a_, fuzzy::cend(b_), b_ };
			}

		private:

			set_t const& a_;
			set_t const& b_;
		};

		template <class V, class M, class Container>
		constexpr typename set_operation_value_sequence<V, M, Container>::iterator begin(set_operation_value_sequence<V, M, Container> const& set) { return set.begin(); }

		template <class V, class M, class Container>
		constexpr typename set_operation_value_sequence<V, M, Container>::iterator end(set_operation_value_sequence<V, M, Container> const& set)   { return set.end();   }

		template <class Operation>
		requires fuzzy::tnorm_type<Operation> || fuzzy::tconorm_type<Operation>
		struct operation
		{
			template <class V, class M, class Container>
			[[nodiscard]] constexpr static fuzzy::basic_set<V, M, Container> apply(fuzzy::basic_set<V, M, Container> const& a, fuzzy::basic_set<V, M, Container> const& b)
			{
				using set_t = fuzzy::basic_set<V, M, Container>;
				using element_t = typename set_t::element_type;
				using op_t = Operation;
				using pair_t = typename set_operation_value_sequence<V, M, Container>::value_t;

				set_t result;
				set_operation_value_sequence<V, M, Container> seq{ a, b };
				for (pair_t pair : seq)
				{
					V v = pair.first.value();
					M m = op_t::apply(pair.first.membership(), pair.second.membership());
					result.insert(element_t{ v, m });
				}
				trim::apply(result);

				return result;
			}
		};


		template <class VF, class V>
		concept ValueFunction = std::integral<V> && requires (V va, V vb, VF vf)
		{
			{ vf(va, vb) } -> std::same_as<V>;
		};

		template <class MF, class M>
		concept MembershipFunction = std::floating_point<M> && requires (M m, MF mf)
		{
			{ mf(m) } -> std::same_as<M>;
		};


		template <class V, class VF>
		requires ValueFunction<VF, V>
		V values(V a, V b, VF vf)
		{
			return vf(a, b);
		}

		/* Triangular conorm function object.**/
		template <typename M = float>
		requires std::floating_point<M>
		class tconorm_binder
		{
		public:
			using tconorm = tconorm_tag;
			using value_type = M;
			using func_ptr = M(*)(M x, M y);

			tconorm_binder() { func_ = [](M, M) { return std::numeric_limits<M>::quiet_NaN(); }; }
			tconorm_binder(tconorm_binder<M> const&) = delete;
			tconorm_binder(tconorm_binder<M>&&) = delete;
			tconorm_binder<M>& operator=(tconorm_binder<M> const&) = delete;
			tconorm_binder<M>& operator=(tconorm_binder<M>&&) = delete;

			/** binds to a specific tconorm type */
			template <typename T>
			requires tconorm_type<T>
			constexpr void bind(T) noexcept
			{
				func_ = [](M x, M y) -> M { return T::apply(x, y); };
			}

			[[nodiscard]] constexpr M apply(M x, M y) noexcept
			{
				validate_range<M>(x, y);
				return func_(x, y);
			}

		private:
			func_ptr func_ = nullptr;
		};

		/* Triangular conorm function object.**/
		template <class M = float>
		requires std::floating_point<M>
		class tnorm_binder
		{
		public:
			using tnorm = tnorm_tag;
			using func_ptr = M(*)(M x, M y);

			tnorm_binder() { func_ = [](M, M) { return std::numeric_limits<M>::quiet_NaN(); }; }
			tnorm_binder(tnorm_binder<M> const&) = delete;
			tnorm_binder(tnorm_binder<M>&&) = delete;
			tnorm_binder<M>& operator=(tnorm_binder<M> const&) = delete;
			tnorm_binder<M>& operator=(tnorm_binder<M>&&) = delete;

			/** binds to a specific tconorm type */
			template <class T>
			requires tnorm_type<T>
			constexpr void bind(T) noexcept
			{
				func_ = [](M x, M y) -> M { return T::apply(x, y); };
			}

			[[nodiscard]] constexpr M apply(M x, M y) noexcept
			{
				validate_range<M>(x, y);
				return func_(x, y);
			}

		private:
			func_ptr func_;
		};

#ifdef FUZZY_USE_TLS_DEF_OPERATOR
		template <class M>
		requires std::floating_point<M>
		thread_local tconorm_binder<M> *current_tconorm = nullptr;

		template <class M>
		requires std::floating_point<M>
		thread_local tnorm_binder<M> *current_tnorm = nullptr;
#endif

		template <class V, class M>
		requires std::integral<V> && std::floating_point<M>
		struct edge
		{
			basic_element<V, M> v0;
			basic_element<V, M> v1;
		};

		template <class V, class M>
		requires std::integral<V>&& std::floating_point<M>
		constexpr std::span<fuzzy::basic_element<V, M>> calculate_linear_steps(fuzzy::basic_element<V,M> le, fuzzy::basic_element<V, M> re, std::span<fuzzy::basic_element<V, M>> steps)
		{
			using math::promote;
			M const dy = re.membership() - le.membership();
			M const dx = static_cast<M>(promote(re.value()) - promote(le.value()));
			M const lm = dy / dx;
			M const lb = le.membership() - (lm * static_cast<M>(le.value()));

			M const step_size = dx / static_cast<M>(steps.size() + 1ull);
			M step_x = step_size + static_cast<M>(le.value());
			for (auto itr = begin(steps); itr != end(steps); ++itr, step_x += step_size)
			{
				const M x = std::round(step_x);
				const M m = (lm * x) + lb;
				const V v = static_cast<V>(x);
				*itr = fuzzy::basic_element<V, M>{ v, m };
			}

			return steps;
		};

		template <class Func, class V, class M, class Operation = fuzzy::maximum<M>, class Container>
		requires std::integral<V>&& std::floating_point<M>
		[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> linguistic_term_impl(fuzzy::basic_set<V, M, Container> const& aset, Func const& func, std::size_t step_count = linguistic_term_default_steps)
		{
			using math::promote;
			using set_type = fuzzy::basic_set<V, M, Container>;
			using element_type = typename set_type::element_type;
			set_type result;

			constexpr M min_threshold = static_cast<M>(0.25);
			constexpr M max_threshold = static_cast<M>(0.95);

			// Handle special cases of empty or 1 element.
			if (aset.empty())
			{
				return result;
			}
			if (aset.size() == 1ull)
			{
				element_type e = aset.front();
				e.membership(std::sqrt(e.membership()));
				result.insert(std::move(e));
			}

			std::array<element_type, linguistic_term_max_steps> buffer = 
			{ 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0}, 
				element_type{0,0.0} 
			};
			auto calc_steps = [&](element_type lhs, element_type rhs) -> std::size_t
			{
				assert(rhs.value() > lhs.value());
				std::size_t const steps = std::min(static_cast<std::size_t>(rhs.value() - lhs.value()) - 1ull, step_count);
				return std::min(steps, buffer.size());
			};

			// Handle the general case.
			auto itr_last = begin(aset);
			assert(itr_last != end(aset));
			for (auto itr = itr_last + 1; itr != end(aset); ++itr_last, ++itr)
			{
				result.insert(element_type{ itr_last->value(), func(itr_last->membership()) });

				M const lm = itr_last->membership();
				M const rm = itr->membership();
				if ((lm > max_threshold && rm < min_threshold) || (lm < min_threshold && rm > max_threshold))
				{
					std::span<element_type> steps = calculate_linear_steps(
						*itr_last,
						*itr,
						std::span<element_type>{ buffer.data(), buffer.data() + calc_steps(*itr_last, *itr) });
					for (auto e : steps)
					{
						result.insert(element_type{ e.value(), func(e.membership()) });
					}
				}
			}
			return result;
		}

	}


	/**
	* Version of std::set_intersection compatible with fuzzy set theory.
	* @param lhs The left hand side fuzzy set operand.
	* @param rhs The right hand side fuzzy set operand.
	* @return The intersection of the two fuzzy sets.
	*/
	template <class V, class M, class Operation = fuzzy::minimum<M>, class Container>
	requires std::integral<V> && std::floating_point<M> && tnorm_type<Operation>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> set_intersection(fuzzy::basic_set<V, M, Container> const& lhs, fuzzy::basic_set<V, M, Container> const& rhs)
	{
		return fuzzy::detail::operation<Operation>::apply(lhs, rhs);
	}

	/**
	* Version of std::set_union compatible with fuzzy set theory.
	* @param lhs The left hand side fuzzy set operand.
	* @param rhs The right hand side fuzzy set operand.
	* @return The union of the two fuzzy sets.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, class Container>
	requires std::integral<V>&& std::floating_point<M>&& tconorm_type<Operation>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> set_union(fuzzy::basic_set<V, M, Container> const& lhs, fuzzy::basic_set<V, M, Container> const& rhs)
	{
		return fuzzy::detail::operation<Operation>::apply(lhs, rhs);
	}

#ifdef FUZZY_USE_TLS_DEF_OPERATOR

	template <class T>
	requires tnorm_type<T> && std::floating_point<typename T::value_type>
	class use_tnorm_t
	{
	public:
		using value_type = typename T::value_type;

		use_tnorm_t() = delete;
		use_tnorm_t(use_tnorm_t<T> const&) = delete;
		use_tnorm_t(use_tnorm_t<T>&&) = delete;
		use_tnorm_t<T>& operator=(use_tnorm_t<T> const&) = delete;
		use_tnorm_t<T>& operator=(use_tnorm_t<T>&&) = delete;

		constexpr use_tnorm_t(T) noexcept
			: previous_(detail::current_tnorm<value_type>)
		{
			current_.bind(T{});
			detail::current_tnorm<value_type> = &current_;
		}

		constexpr ~use_tnorm_t() noexcept
		{
			assert(detail::current_tnorm<value_type> == &current_);
			detail::current_tnorm<value_type> = previous_;
		}

	private:
		detail::tnorm_binder<value_type> current_;
		detail::tnorm_binder<value_type> *previous_;
	};

	template<class T> use_tnorm_t(T) -> use_tnorm_t<T>;
	

	template <class T>
	requires tconorm_type<T>&& std::floating_point<typename T::value_type>
	class use_tconorm_t
	{
	public:
		using value_type = typename T::value_type;

		use_tconorm_t() = delete;
		use_tconorm_t(use_tconorm_t<T> const&) = delete;
		use_tconorm_t(use_tconorm_t<T>&&) = delete;
		use_tconorm_t<T>& operator=(use_tconorm_t<T> const&) = delete;
		use_tconorm_t<T>& operator=(use_tconorm_t<T>&&) = delete;

		constexpr use_tconorm_t(T) noexcept
			: previous_(detail::current_tconorm<value_type>)
		{
			current_.bind(T{});
			detail::current_tconorm<value_type> = &current_;
		}

		constexpr ~use_tconorm_t() noexcept
		{
			assert(detail::current_tconorm<value_type> == &current_);
			detail::current_tconorm<value_type> = previous_;
		}

	private:
		detail::tconorm_binder<value_type> current_;
		detail::tconorm_binder<value_type>* previous_;
	};

	template<class T> use_tconorm_t(T) -> use_tconorm_t<T>;





#endif

	/**
	* Intersects two fuzzy sets.
	* @param aset The lhs set to intersect.
	* @return The intersection of the sets.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, class Container>
	requires std::integral<V>&& std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> operator&(fuzzy::basic_set<V, M, Container> const& lhs, fuzzy::basic_set<V, M, Container> const& rhs)
	{
		return set_intersection<V, M, Operation, Container>(lhs, rhs);
	}

	/**
	* Unions two fuzzy sets.
	* @param aset The lhs set to intersect.
	* @return The unions of the sets.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, class Container>
		requires std::integral<V>&& std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> operator|(fuzzy::basic_set<V, M, Container> const& lhs, fuzzy::basic_set<V, M, Container> const& rhs)
	{
		return set_union<V, M, Operation, Container>(lhs, rhs);
	}

	/**
	* Complement of fuzzy set.
	* @param aset The set to complement.
	* @return The complement of the set.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, class Container>
	requires std::integral<V>&& std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> set_complement(fuzzy::basic_set<V, M, Container> const& aset)
	{
		using set_type = fuzzy::basic_set<V, M, Container>;
		using element_type = typename set_type::element_type;
		set_type result;

		constexpr V v_min = std::numeric_limits<V>::lowest();
		constexpr V v_max = std::numeric_limits<V>::max();
		constexpr V v_offset = static_cast<V>(1);
		constexpr M m_max = static_cast<M>(1.0);
		constexpr M m_min = static_cast<M>(0.0);
		constexpr complement<M> comp;

		if (aset.empty())
		{
			result.insert(element_type{ v_min, m_max });
			result.insert(element_type{ v_max, m_max });
			return result;
		}

		M const m_front = comp.apply(aset.front().membership());
		if (m_front != m_min && aset.front().value() != v_min)
		{
			V const v_prefix = aset.front().value() - v_offset;
			if (v_prefix != v_min)
				result.insert(element_type{ v_min, m_max });

			if (m_front != m_min)
				result.insert(element_type{ v_prefix, m_max });
		}

		for (auto& element : aset)
		{
			result.insert(fuzzy::basic_element<V, M>{ element.value(), comp.apply(element.membership()) });
		}

		M const m_back = result.back().membership();
		if (m_back != m_min && aset.back().value() != v_max)
		{
			V const v_postfix = aset.back().value() + v_offset;
			if (v_postfix != v_max)
				result.insert(element_type{ v_max, m_max });

			if (m_back != m_min)
				result.insert(element_type{ v_postfix, m_max });
		}

		return result;
	}


	/**
	* Fuzzy term 'somewhat' relaxes requirement for the fuzzy set.
	* @param aset The set to relax.
	* @return The relaxed set.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, class Container>
	requires std::integral<V>&& std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> somewhat(fuzzy::basic_set<V, M, Container> const& aset, std::size_t steps = linguistic_term_default_steps)
	{
		constexpr auto somewhat_func = [](M m) { return std::sqrt(m); };
		return detail::linguistic_term_impl(aset, somewhat_func, steps);
	}

	/**
	* Fuzzy term 'verry' tightens requirement for the fuzzy set.
	* @param aset The set to tighten.
	* @return The tightened set.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, class Container>
	requires std::integral<V>&& std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> very(fuzzy::basic_set<V, M, Container> const& aset, std::size_t steps = linguistic_term_default_steps)
	{
		constexpr auto very_func = [](M m) { return m * m; };
		return detail::linguistic_term_impl(aset, very_func, steps);
	}

	/**
	* Complement of fuzzy set.
	* @param aset The set to complement.
	* @return The complement of the set.
	*/
	template <class V, class M, class Operation = fuzzy::maximum<M>, class Container>
	requires std::integral<V>&& std::floating_point<M>
	[[nodiscard]] constexpr fuzzy::basic_set<V, M, Container> operator~(fuzzy::basic_set<V, M, Container> const& aset)
	{
		return set_complement<V,M,Operation, Container>(aset);
	}


}

#endif // FUZZY_ALGORITHM_HPP