//  Copyright (c) 2025, Ben McCart
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.

#include <limits>
#include <memory>
#include <vector>

#include <fuzzy/concepts.hpp>
#include <fuzzy/math.hpp>
#include <fuzzy/set.hpp>

#ifndef FUZZY_DEFUZZIFICATION_HPP
#define FUZZY_DEFUZZIFICATION_HPP

namespace fuzzy
{
	namespace detail
	{
		template <class V, class M>
		requires fuzzy::numeric<V>&& std::floating_point<M>
		struct mean_of_max_result_t
		{
			V value;
			M max;
		};

		template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
		requires fuzzy::numeric<V> && std::floating_point<M>
		[[nodiscard]] constexpr mean_of_max_result_t<V,M> mean_of_maximum(fuzzy::basic_set<V, M, Container, Allocator> const& aset)
		{
			if (aset.empty())
				return mean_of_max_result_t<V,M>{ .value = std::numeric_limits<V>::max(), .max = static_cast<M>(0) };

			if (aset.size() == 1u)
				return mean_of_max_result_t<V,M>{ .value = aset.front().value(), .max = aset.front().membership() };

			M max = std::numeric_limits<M>::lowest();
			M last_membership = std::numeric_limits<M>::lowest();
			M value_sum = static_cast<M>(0);
			M value_count = 0.0;
			V last_value = std::numeric_limits<V>::lowest();
			for (auto const& e : aset)
			{
				if (fuzzy::math::equivelant(e.membership(), max))
				{
					if (fuzzy::math::equivelant(e.membership(), last_membership))
					{
						assert(last_value != std::numeric_limits<M>::lowest());

						// Calculate the accumulative sum / count.
						M const mean = (static_cast<M>(e.value()) + static_cast<M>(last_value)) / static_cast<M>(2);
						M const count = static_cast<M>(e.value() - last_value) + static_cast<M>(1);
						M const accumulative_sum = mean * count;

						// Adjust to account for prior max/count addition.
						M const adjusted_count = count - static_cast<M>(1);
						M const adjusted_mean = accumulative_sum - static_cast<M>(last_value);

						value_count += adjusted_count;
						value_sum += adjusted_mean;
					}
					else
					{
						value_count += static_cast<M>(1);
						value_sum += static_cast<M>(e.value());
					}
				}
				else if (e.membership() > max)
				{
					value_count = 1u;
					max = e.membership();
					value_sum = e.value();
				}

				last_value = e.value();
				last_membership = e.membership();
			}

			V value = static_cast<V>(fuzzy::math::round<V>(fuzzy::math::round<V>(value_sum / value_count)));
			return mean_of_max_result_t<V,M>{ .value = value, .max = max };
		}
	}

	/**
	 * @brief Calculate the mean-of-maximum of the fuzzy set.
	 * @tparam V The value type.
	 * @tparam M The memberhsip type.
	 * @tparam Allocator The allocator type.
	 * @param aset The set to calculate the mean-of-maximum for.
	 * @return The crisp value.
	*/
	template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
	requires fuzzy::numeric<V> && std::floating_point<M>
	[[nodiscard]] constexpr V mean_of_maximum(fuzzy::basic_set<V, M, Container, Allocator> const& aset)
	{
		detail::mean_of_max_result_t<V,M> result = detail::mean_of_maximum(aset);
		return result.value;
	}

	/**
	 * @brief Calculate the mean-of-maximum of the fuzzy set but constrains the value to the nearest maxima.
	 * @tparam V The value type.
	 * @tparam M The memberhsip type.
	 * @tparam Allocator The allocator type.
	 * @param aset The set to calculate the mean-of-maximum for.
	 * @return The crisp value.
	*/
	template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
	requires fuzzy::numeric<V>&& std::floating_point<M>
	[[nodiscard]] constexpr V mean_of_maximum_nearest_maxima(fuzzy::basic_set<V, M, Container, Allocator> const& aset)
	{
		detail::mean_of_max_result_t<V,M> result = detail::mean_of_maximum(aset);
		if (fuzzy::math::equivelant(result.max, aset.membership(result.value)))
			return result.value;

		// Search the lower bound for a maxima.
		M lb_diff = std::numeric_limits<M>::infinity();
		auto const lb_end = aset.rend();
		auto const itr_beg = aset.lower_bound(result.value);
		for (auto lb_itr = std::reverse_iterator{ itr_beg }; lb_itr != lb_end; ++lb_itr)
		{
			if (fuzzy::math::equivelant(lb_itr->membership(), result.max))
			{
				lb_diff = static_cast<M>(result.value) - static_cast<M>(lb_itr->value());
				break;
			}
		}

		// Search the upper bound for a maxima.
		M ub_diff = std::numeric_limits<M>::infinity();
		for (auto ub_itr = itr_beg; ub_itr != aset.end(); ++ub_itr)
		{
			if (fuzzy::math::equivelant(ub_itr->membership(), result.max))
			{
				ub_diff = static_cast<M>(ub_itr->value()) - static_cast<M>(result.value);
				break;
			}
		}

		// Which ever is closest wins (prefering upper bound on tie).
		assert(lb_diff != std::numeric_limits<M>::max() || ub_diff != std::numeric_limits<M>::max());
		if (lb_diff < ub_diff)
			return result.value - lb_diff;
		else
			return result.value + ub_diff;
	}

	/**
	 * @brief Calculate the center of area of the fuzzy set.
	 * @tparam V The value type.
	 * @tparam M The memberhsip type.
	 * @tparam Allocator The allocator type.
	 * @param aset The set to calculate the mean-of-maximum for.
	 * @return The crisp value.
	*/
	template <class V, class M, template <typename T, typename Alloc> class Container, class Allocator>
	requires fuzzy::numeric<V>&& std::floating_point<M>
	[[nodiscard]] constexpr V center_of_area(fuzzy::basic_set<V, M, Container, Allocator> const& aset)
	{
		using element_t = basic_element<V,M>;
		if (aset.empty())
			return std::numeric_limits<V>::max();

		if (aset.size() == 1u)
			return aset.front().value();

		auto add_first = [&]()
		{
			M m = aset.front().membership();
			return !fuzzy::math::equivelant(m, static_cast<M>(0));
		};
		auto add_last = [&]()
		{
			M m = aset.back().membership();
			return !fuzzy::math::equivelant(m, static_cast<M>(0));
		};
		auto first_vertex = [&]()
		{
			return element_t{ aset.front().value(), static_cast<M>(0) };
		};
		auto last_vertex = [&]()
		{
			return element_t{ aset.back().value(), static_cast<M>(0) };
		};

		M area = static_cast<M>(0);
		M cx = static_cast<M>(0);

		auto append_area = [&](element_t const& v0, element_t const& v1) noexcept -> void
		{
			M xproduct = static_cast<M>(v0.value()) * v1.membership() - static_cast<M>(v1.value()) * v0.membership();
			area += xproduct;
			cx += (static_cast<M>(v0.value()) + static_cast<M>(v1.value())) * xproduct;
		};

		if (add_first())
			append_area(first_vertex(), aset.front());

		auto itr = aset.cbegin();
		for (auto itr_next = itr + 1; itr_next != aset.cend(); ++itr, ++itr_next)
		{
			append_area(*itr, *itr_next);
		}

		if (add_last())
			append_area(aset.back(), last_vertex());

		// Close the polygon.
		element_t v0 = add_last() ? last_vertex() : aset.back();
		element_t v1 = add_first() ? first_vertex() : aset.front();
		append_area(v0, v1);

		// Handle special degenerate case.
		area *= static_cast<M>(0.5);
		if (fuzzy::math::equivelant(area, static_cast<M>(0)))
			return static_cast<M>((aset.front().value() + aset.back().value()) / static_cast<M>(2));

		return static_cast<V>(cx / (static_cast<M>(6) * area));
	}

	

}


#endif // FUZZY_DEFUZZIFICATION_HPP