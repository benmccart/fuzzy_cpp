//  Copyright (c) 2022, Ben McCart
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.



#ifndef FUZZY_RELATION_HPP
#define FUZZY_RELATION_HPP

#include <fuzzy/set.hpp>
#include <fuzzy/traits.hpp>


namespace fuzzy
{
	/**
	* Forms a relation between the two sets by creating a cartesian product.
	*
	*/
	template <class V, class M, class Container = std::vector<basic_element<V, M>>, class Operation = fuzzy::minimum<M>>
	requires tnorm_type<Operation> && std::integral<V> && std::floating_point<M>
	class relation
	{
	public:
		using set_t = basic_set<V, M, Container>;
		using self_t = relation<V, M, Container, Operation>;

		relation() = delete;
		constexpr relation(set_t const&, set_t const&) noexcept;

		constexpr relation(set_t const&, set_t const&, Operation op) noexcept;

		//constexpr relation(self_t const&) = default;
		//relation(self_t&&) = delete;
		//self_t& operator=(self_t const&) = delete;
		//self_t& operator=(self_t&&) = delete;

		constexpr M membership(V, V) const noexcept;

	private:
		set_t const * a_;
		set_t const * b_;
	};

	template<class V, class M, class Container = std::vector<basic_element<V, M>>, class Operation> relation(basic_set<V,M,Container> const&, basic_set<V, M, Container> const&, Operation op) ->
	relation<V,M, basic_set<V, M, Container>, Operation>;

	template <class V, class M, class Container, class Operation>
	requires tnorm_type<Operation> && std::integral<V> && std::floating_point<M>
	constexpr relation<V, M, Container, Operation>::relation(set_t const &a, set_t const &b) noexcept
		: a_(&a)
		, b_(&b)
	{

	}

	template <class V, class M, class Container, class Operation>
	requires tnorm_type<Operation> && std::integral<V> && std::floating_point<M>
	constexpr relation<V, M, Container, Operation>::relation(set_t const& a, set_t const& b, Operation op) noexcept
		: a_(&a)
		, b_(&b)
	{

	}

	template <class V, class M, class Container, class Operation>
	requires tnorm_type<Operation> && std::integral<V> && std::floating_point<M>
	constexpr M relation<V, M, Container, Operation>::membership(V av, V bv) const noexcept
	{
		return Operation::apply(a_->membership(av), b_->membership(bv));
	}


}


#endif // FUZZY_RELATION_HPP
