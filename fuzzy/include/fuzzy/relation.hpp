//  Copyright (c) 2022, Ben McCart
//  Boost Software License - Version 1.0 - August 17th, 2003
//
//  Permission is hereby granted, free of charge, to any person or organization
//  obtaining a copy of the software and accompanying documentation covered by
//  this license (the "Software") to use, reproduce, display, distribute,
//  execute, and transmit the Software, and to prepare derivative works of the
//  Software, and to permit third-parties to whom the Software is furnished to
//  do so, all subject to the following:
//
//  The copyright notices in the Software and this entire statement, including
//  the above license grant, this restriction and the following disclaimer,
//  must be included in all copies of the Software, in whole or in part, and
//  all derivative works of the Software, unless such copies or derivative
//  works are solely in the form of machine-executable object code generated by
//  a source language processor.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
//  IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
//  FITNESS FOR A PARTICULAR PURPOSE, TITLE AND NON-INFRINGEMENT. IN NO EVENT
//  SHALL THE COPYRIGHT HOLDERS OR ANYONE DISTRIBUTING THE SOFTWARE BE LIABLE
//  FOR ANY DAMAGES OR OTHER LIABILITY, WHETHER IN CONTRACT, TORT OR OTHERWISE,
//  ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
//  DEALINGS IN THE SOFTWARE.



#ifndef FUZZY_RELATION_HPP
#define FUZZY_RELATION_HPP

#include <fuzzy/set.hpp>
#include <fuzzy/traits.hpp>


namespace fuzzy
{
	/**
	* Forms domain relation between the two sets by creating domain cartesian product represented as the membership of the relation.
	*/
	template <class V, class M, class Container = std::vector<basic_element<V, M>>, class Operation = fuzzy::minimum<M>>
	requires tnorm_type<Operation> && std::integral<V> && std::floating_point<M>
	class relation
	{
	public:
		using set_type = basic_set<V, M, Container>;
		using self_t = relation<V, M, Container, Operation>;

		relation() = delete;
		constexpr relation(set_type const&, set_type const&) noexcept;
		constexpr relation(set_type const&, set_type const&, Operation op) noexcept;

		//relation(self_t const&) = default;
		//relation(self_t&&) = delete;
		//self_t& operator=(self_t const&) = delete;
		//self_t& operator=(self_t&&) = delete;

		constexpr M membership(V, V) const noexcept;

		constexpr set_type const& domain() const noexcept { return *domain_; }
		constexpr set_type const& range() const noexcept  { return *range_;  }

	private:
		set_type const * domain_;
		set_type const * range_;
	};
	/** Deduction guide to help construct the relation without having to explicitly specify the operation template parameter. */
	template<class V, class M, class Container = std::vector<basic_element<V, M>>, class Operation> relation(basic_set<V,M,Container> const&, basic_set<V, M, Container> const&, Operation op) ->
	relation<V,M, basic_set<V, M, Container>, Operation>;

	/** 
	* Constructs the relation from the two provided sets.
	* @param domain - the domain the relation is to operate on.
	* @param range - the range of the relation.
	*/
	template <class V, class M, class Container, class Operation>
	requires tnorm_type<Operation> && std::integral<V> && std::floating_point<M>
	constexpr relation<V, M, Container, Operation>::relation(set_type const &domain, set_type const &range) noexcept
		: domain_(&domain)
		, range_(&range)
	{

	}

	/** 
	* Constructs the relation from the two provided sets.
	* @param domain - the domain the relation is to operate on.
	* @param range - the range of the relation.
	* @param op - the t-norm operation to employ in the construction of the relation.
	*/
	template <class V, class M, class Container, class Operation>
	requires tnorm_type<Operation> && std::integral<V> && std::floating_point<M>
	constexpr relation<V, M, Container, Operation>::relation(set_type const& domain, set_type const& range, Operation op) noexcept
		: domain_(&domain)
		, range_(&range)
	{

	}

	/**
	* Retrieves the membership of the relation as the cartesian product of the domain x range
	* using the t-norm operator supplied at construction.
	* @param dv - domain value.
	* @param rv - range value.
	* @result The memberhsip (cartesian product) of the relation at the dv x rv.
	*/
	template <class V, class M, class Container, class Operation>
	requires tnorm_type<Operation> && std::integral<V> && std::floating_point<M>
	constexpr M relation<V, M, Container, Operation>::membership(V dv, V rv) const noexcept
	{
		return Operation::apply(domain_->membership(dv), range_->membership(rv));
	}
}


#endif // FUZZY_RELATION_HPP
